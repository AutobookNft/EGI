quello che descrivi è un carousel “centered peek / coverflow”.
L’elemento centrale è più grande e alza lo z-index; a sinistra e destra “sporgono” i vicini, più piccoli e un filo sfocati/attenuati. È il pattern tipico “piramide vista dall’alto”.

Dalla home di Collecto si intuisce uno slider hero con più asset e CTA store; non posso leggere il loro JS minificato da qui, ma il comportamento è quello (“centered + peek”) usato da librerie come Swiper/Splide/Slick o con JS custom. 
collectoapp.com

Ti lascio una implementazione pulita, mobile-first, senza librerie, che replica esattamente quell’effetto. La agganci al tuo componente Stream e sei a casa.

Componente Coverflow (Blade + TS + Tailwind)
HTML/Blade (estratto)
<section id="stream-egi" class="mb-10" data-coverflow>
  <div class="flex items-center justify-between mb-3 px-4">
    <h2 class="text-lg font-semibold">EGI in evidenza</h2>
    <div class="inline-flex rounded-xl bg-slate-800/60 p-1 gap-1">
      <button class="px-3 py-1 text-sm rounded-lg data-[active=true]:bg-slate-700"
              data-action="set-view" data-view="carousel">Carosello</button>
      <button class="px-3 py-1 text-sm rounded-lg data-[active=true]:bg-slate-700"
              data-action="set-view" data-view="list">Lista</button>
    </div>
  </div>

  <!-- TRACK -->
  <div class="relative">
    <div class="flex gap-3 overflow-x-auto snap-x snap-mandatory scroll-pl-6 pr-6 pl-6
                will-change-transform"
         data-track tabindex="0" aria-label="EGI in evidenza">
      @foreach($items as $item)
        <article class="snap-center shrink-0 w-[80%] sm:w-[60%] md:w-[46%] lg:w-[36%]
                        transition-transform duration-200 ease-out
                        rounded-xl bg-slate-800/60 border border-slate-700 overflow-hidden"
                 data-slide data-url="{{ $item->url }}">
          <div class="aspect-[16/11] bg-slate-900">
            <img loading="lazy" src="{{ $item->image }}" alt="{{ $item->title }}"
                 class="w-full h-full object-cover">
          </div>
          <div class="p-3">
            <h3 class="font-medium text-slate-100 truncate">{{ $item->title }}</h3>
            <div class="mt-1 text-sm text-slate-300">
              <span class="font-semibold">{{ $item->price }}</span><span class="opacity-70"> ≈ ALGO</span>
            </div>
            <a href="{{ $item->ctaUrl }}" class="mt-3 w-full inline-flex justify-center rounded-lg px-3 py-2 bg-violet-600 hover:bg-violet-700">
              {{ $item->ctaLabel ?? 'Prenota' }}
            </a>
          </div>
        </article>
      @endforeach
    </div>

    <!-- Arrows -->
    <div class="pointer-events-none absolute inset-y-0 left-0 right-0 flex justify-between items-center px-2">
      <button class="pointer-events-auto rounded-full p-2 bg-slate-900/70" data-arrow="-1" aria-label="Indietro">«</button>
      <button class="pointer-events-auto rounded-full p-2 bg-slate-900/70" data-arrow="1"  aria-label="Avanti">»</button>
    </div>

    <!-- Edge fade (opzionale) -->
    <div class="pointer-events-none absolute inset-y-0 left-0 w-10 bg-gradient-to-r from-slate-900 to-transparent"></div>
    <div class="pointer-events-none absolute inset-y-0 right-0 w-10 bg-gradient-to-l from-slate-900 to-transparent"></div>
  </div>

  <!-- LIST (fallback) -->
  <div class="hidden px-4" data-list>
    <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
      {{-- riusa la stessa card --}}
    </div>
  </div>
</section>

TypeScript (drop-in)
// resources/js/coverflow.ts
type View = 'carousel'|'list';

function setView(root: HTMLElement, view: View) {
  const track = root.querySelector<HTMLElement>('[data-track]')!;
  const list  = root.querySelector<HTMLElement>('[data-list]')!;
  if (view === 'carousel') { track.classList.remove('hidden'); list.classList.add('hidden'); }
  else { list.classList.remove('hidden'); track.classList.add('hidden'); }
  root.querySelectorAll<HTMLButtonElement>('[data-action="set-view"]').forEach(b => {
    b.dataset.active = (b.dataset.view === view).toString();
  });
}

function centerOn(track: HTMLElement, slide: HTMLElement) {
  const r = track.getBoundingClientRect();
  const s = slide.getBoundingClientRect();
  const delta = (s.left + s.width/2) - (r.left + r.width/2);
  track.scrollBy({ left: delta, behavior: 'smooth' });
}

function initCoverflow(root: HTMLElement) {
  const track = root.querySelector<HTMLElement>('[data-track]')!;
  const slides = Array.from(track.querySelectorAll<HTMLElement>('[data-slide]'));

  // View toggle + persistence
  const id = root.id || crypto.randomUUID(); root.id = id;
  const saved = (localStorage.getItem(`coverflow:view:${id}`) as View) || 'carousel';
  setView(root, saved);
  root.querySelectorAll<HTMLButtonElement>('[data-action="set-view"]').forEach(b => {
    b.addEventListener('click', () => {
      const v = (b.dataset.view as View) || 'carousel';
      setView(root, v);
      localStorage.setItem(`coverflow:view:${id}`, v);
    });
  });

  // Arrow buttons
  root.querySelectorAll<HTMLButtonElement>('[data-arrow]').forEach(btn => {
    btn.addEventListener('click', () => {
      const dir = parseInt(btn.dataset.arrow || '1', 10);
      const one = slides[0];
      const step = one ? (one.getBoundingClientRect().width + 12) : 320;
      track.scrollBy({ left: step * dir, behavior: 'smooth' });
    });
  });

  // Coverflow effect
  const prefersReduced = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
  const update = () => {
    const tr = track.getBoundingClientRect();
    const center = tr.left + tr.width / 2;

    slides.forEach((el) => {
      const r = el.getBoundingClientRect();
      const c = r.left + r.width / 2;
      const dist = Math.abs(center - c);
      const norm = Math.min(1, dist / (tr.width * 0.6)); // 0..1
      const scale = 1 - norm * 0.15;                     // 1..0.85
      const opacity = 0.6 + (1 - norm) * 0.4;            // 0.6..1
      const rotate = ((center - c) / (tr.width/2)) * 6;  // -6..6 deg

      el.style.zIndex = String(1000 - Math.round(norm * 1000));
      el.style.opacity = String(opacity);
      el.style.transform = prefersReduced
        ? `scale(${scale})`
        : `perspective(1000px) rotateY(${rotate}deg) scale(${scale})`;
      el.style.transition = 'transform 120ms ease-out, opacity 120ms ease-out';
    });

    requestAnimationFrame(update);
  };
  update();

  // Click sui laterali -> centra
  slides.forEach(s => {
    s.addEventListener('click', (e) => {
      const tr = track.getBoundingClientRect();
      const sr = s.getBoundingClientRect();
      const isCentered = Math.abs((sr.left + sr.width/2) - (tr.left + tr.width/2)) < 8;
      if (!isCentered) { e.preventDefault(); centerOn(track, s); }
    });
  });

  // Keyboard (← →)
  track.addEventListener('keydown', (e: KeyboardEvent) => {
    if (e.key === 'ArrowRight' || e.key === 'PageDown') { e.preventDefault(); track.scrollBy({ left: 320, behavior: 'smooth' }); }
    if (e.key === 'ArrowLeft'  || e.key === 'PageUp')   { e.preventDefault(); track.scrollBy({ left: -320, behavior: 'smooth' }); }
  });
}

// bootstrap
export function initCoverflows() {
  document.querySelectorAll<HTMLElement>('[data-coverflow]').forEach(initCoverflow);
}


In app.ts chiama initCoverflows() su DOMContentLoaded.