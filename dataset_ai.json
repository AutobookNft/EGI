[
{
  "name": "CreateNewUser",
  "code": "<?php\n\nnamespace App\\Actions\\Fortify;\n\nuse App\\Models\\User;\nuse App\\Models\\Collection;\nuse App\\Traits\\HasCreateDefaultCollectionWallets;\nuse App\\Traits\\HasUtilitys;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Laravel\\Fortify\\Contracts\\CreatesNewUsers;\nuse Spatie\\Permission\\Models\\Role;\n\nclass CreateNewUser implements CreatesNewUsers\n{\n    use PasswordValidationRules;\n    use HasCreateDefaultCollectionWallets;\n    use HasUtilitys;\n\n\n    /**\n     * Crea un nuovo utente registrato.\n     *\n     * @param  array<string, string>  $input\n     */\n    public function create(array $input): User\n    {\n        Log::channel('florenceegi')->info('Classe: CreateNewUser Metodo create: INIZIO', ['input' => $input]);\n\n        // Validazione dell'input\n        $this->validateInput($input);\n\n        // Generazione dei dettagli del wallet\n        [$wallet_address, $wallet_balance] = $this->generateWalletDetails();\n\n        // Creazione dell'utente e delle risorse collegate\n        return $this->handleUserCreation($input, $wallet_address, $wallet_balance);\n    }\n\n    private function validateInput(array $input): void\n    {\n        try {\n            Validator::make($input, [\n                'name' => ['required', 'string', 'max:255'],\n                'email' => ['required', 'string', 'email', 'max:255', 'unique:users'],\n                'password' => $this->passwordRules(),\n            ])->validate();\n\n            Log::channel('florenceegi')->info('Classe: CreateNewUser Metodo validateInput: VALIDAZIONE OK');\n        } catch (\\Illuminate\\Validation\\ValidationException $e) {\n            Log::channel('florenceegi')->error('Errore di validazione', ['errors' => $e->errors()]);\n            throw $e;\n        }\n    }\n\n    private function generateWalletDetails(): array\n    {\n        $wallet_address = $this->generateFakeAlgorandAddress();\n        Log::channel('florenceegi')->info('Generato wallet address', ['wallet_address' => $wallet_address]);\n\n        $wallet_balance = config('app.virtual_wallet_balance');\n        Log::channel('florenceegi')->info('Generato wallet balance', ['wallet_balance' => $wallet_balance]);\n\n        return [$wallet_address, $wallet_balance];\n    }\n\n    private function handleUserCreation(array $input, string $wallet_address, float $wallet_balance): User\n    {\n        return DB::transaction(function () use ($input, $wallet_address, $wallet_balance) {\n            return tap(User::create([\n                'name' => $input['name'],\n                'email' => $input['email'],\n                'wallet' => $wallet_address,\n                'wallet_balance' => $wallet_balance,\n                'language' => app()->getLocale(),\n                'password' => Hash::make($input['password']),\n            ]), function (User $user) {\n                Log::channel('florenceegi')->info('Utente creato con successo', ['user_id' => $user->id]);\n\n                // Crea la collection e i wallet predefiniti\n                $this->createDefaultCollection($user);\n            });\n        });\n    }\n\n    /**\n     * Crea una collection predefinita per l'utente.\n     */\n    protected function createDefaultCollection(User $user): void\n    {\n        tap(Collection::create([\n            'user_id' => $user->id,\n            'epp_id' => config('app.epp_id'),\n            'collection_name' => explode(' ', $user->name, 2)[0] . \"'s Collection\",\n            'description' => __('collection.default_description'),\n            'creator_id' => $user->id,\n            'type' => 'standard',\n            'position' => 1,\n            'EGI_number' => 1,\n            'floor_price' => 0.0,\n            'is_published' => false,\n        ]), function (Collection $collection) use ($user) {\n            Log::channel('florenceegi')->info('Collection creata con successo', ['collection_id' => $collection->id]);\n\n            // Associa l'utente alla collection nella tabella pivot collection_user\n            $collection->users()->attach($user->id, ['role' => 'creator']);\n\n            // Crea i wallet predefiniti per la collection\n            $this->attachDefaultWallets($collection, $user);\n\n            // Assegna il ruolo di creator all'utente\n            $this->assignCreatorRole($user->id);\n        });\n    }\n\n    public function assignCreatorRole(int $userId)\n    {\n        $user = User::find($userId);\n\n        if (!$user) {\n            Log::channel('florenceegi')->error('Utente non trovato durante l\\'assegnazione del ruolo', ['user_id' => $userId]);\n            return;\n        }\n\n        $creatorRole = Role::firstOrCreate(['name' => 'creator']);\n\n        if (!$user->hasRole('creator')) {\n            $user->assignRole($creatorRole);\n            Log::channel('florenceegi')->info('Assegnato ruolo creator all\\'utente', ['user_id' => $userId]);\n        }\n    }\n\n    /**\n     * Crea i wallet predefiniti per la collection.\n     */\n    protected function attachDefaultWallets(Collection $collection, User $user): void\n    {\n        $defaultWallets = [\n            ['user_id' => $user->id, 'wallet' => $user->wallet, 'royalty_mint' => 50.0, 'royalty_rebind' => 10.0], // Wallet Creator\n            ['user_id' => config('app.natan_id'), 'wallet' => config('app.natan_wallet_address'), 'royalty_mint' => 25.0, 'royalty_rebind' => 5.0], // Wallet Natan\n            ['user_id' => config('app.epp_id'), 'wallet' => config('app.epp_wallet_address'), 'royalty_mint' => 25.0, 'royalty_rebind' => 5.0], // Wallet EPP\n        ];\n\n        foreach ($defaultWallets as $wallet) {\n            $collection->wallets()->create($wallet);\n        }\n\n        Log::channel('florenceegi')->info('Wallet predefiniti associati alla collection', ['collection_id' => $collection->id]);\n    }\n}"
}
,
{
  "name": "PasswordValidationRules",
  "code": "<?php\n\nnamespace App\\Actions\\Fortify;\n\nuse Illuminate\\Validation\\Rules\\Password;\n\ntrait PasswordValidationRules\n{\n    /**\n     * Get the validation rules used to validate passwords.\n     *\n     * @return array<int, \\Illuminate\\Contracts\\Validation\\Rule|array<mixed>|string>\n     */\n    protected function passwordRules(): array\n    {\n        return ['required', 'string', Password::default(), 'confirmed'];\n    }\n}"
}
,
{
  "name": "ResetUserPassword",
  "code": "<?php\n\nnamespace App\\Actions\\Fortify;\n\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Laravel\\Fortify\\Contracts\\ResetsUserPasswords;\n\nclass ResetUserPassword implements ResetsUserPasswords\n{\n    use PasswordValidationRules;\n\n    /**\n     * Validate and reset the user's forgotten password.\n     *\n     * @param  array<string, string>  $input\n     */\n    public function reset(User $user, array $input): void\n    {\n        Validator::make($input, [\n            'password' => $this->passwordRules(),\n        ])->validate();\n\n        $user->forceFill([\n            'password' => Hash::make($input['password']),\n        ])->save();\n    }\n}"
}
,
{
  "name": "UpdateUserPassword",
  "code": "<?php\n\nnamespace App\\Actions\\Fortify;\n\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Hash;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Laravel\\Fortify\\Contracts\\UpdatesUserPasswords;\n\nclass UpdateUserPassword implements UpdatesUserPasswords\n{\n    use PasswordValidationRules;\n\n    /**\n     * Validate and update the user's password.\n     *\n     * @param  array<string, string>  $input\n     */\n    public function update(User $user, array $input): void\n    {\n        Validator::make($input, [\n            'current_password' => ['required', 'string', 'current_password:web'],\n            'password' => $this->passwordRules(),\n        ], [\n            'current_password.current_password' => __('The provided password does not match your current password.'),\n        ])->validateWithBag('updatePassword');\n\n        $user->forceFill([\n            'password' => Hash::make($input['password']),\n        ])->save();\n    }\n}"
}
,
{
  "name": "UpdateUserProfileInformation",
  "code": "<?php\n\nnamespace App\\Actions\\Fortify;\n\nuse App\\Models\\User;\nuse Illuminate\\Contracts\\Auth\\MustVerifyEmail;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Validation\\Rule;\nuse Laravel\\Fortify\\Contracts\\UpdatesUserProfileInformation;\n\nclass UpdateUserProfileInformation implements UpdatesUserProfileInformation\n{\n    /**\n     * Validate and update the given user's profile information.\n     *\n     * @param  array<string, mixed>  $input\n     */\n    public function update(User $user, array $input): void\n    {\n        Validator::make($input, [\n            'name' => ['required', 'string', 'max:255'],\n            'email' => ['required', 'email', 'max:255', Rule::unique('users')->ignore($user->id)],\n            'photo' => ['nullable', 'mimes:jpg,jpeg,png', 'max:1024'],\n        ])->validateWithBag('updateProfileInformation');\n\n        if (isset($input['photo'])) {\n            $user->updateProfilePhoto($input['photo']);\n        }\n\n        if ($input['email'] !== $user->email &&\n            $user instanceof MustVerifyEmail) {\n            $this->updateVerifiedUser($user, $input);\n        } else {\n            $user->forceFill([\n                'name' => $input['name'],\n                'email' => $input['email'],\n            ])->save();\n        }\n    }\n\n    /**\n     * Update the given verified user's profile information.\n     *\n     * @param  array<string, string>  $input\n     */\n    protected function updateVerifiedUser(User $user, array $input): void\n    {\n        $user->forceFill([\n            'name' => $input['name'],\n            'email' => $input['email'],\n            'email_verified_at' => null,\n        ])->save();\n\n        $user->sendEmailVerificationNotification();\n    }\n}"
}
,
{
  "name": "AddTeamMember",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Closure;\nuse Illuminate\\Support\\Facades\\Gate;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Laravel\\Jetstream\\Contracts\\AddsTeamMembers;\nuse Laravel\\Jetstream\\Events\\AddingTeamMember;\nuse Laravel\\Jetstream\\Events\\TeamMemberAdded;\nuse Laravel\\Jetstream\\Jetstream;\nuse Laravel\\Jetstream\\Rules\\Role;\n\nclass AddTeamMember implements AddsTeamMembers\n{\n    /**\n     * Add a new team member to the given team.\n     */\n    public function add(User $user, Team $team, string $email, ?string $role = null): void\n    {\n        Gate::forUser($user)->authorize('addTeamMember', $team);\n\n        $this->validate($team, $email, $role);\n\n        $newTeamMember = Jetstream::findUserByEmailOrFail($email);\n\n        AddingTeamMember::dispatch($team, $newTeamMember);\n\n        $team->users()->attach(\n            $newTeamMember, ['role' => $role]\n        );\n\n        TeamMemberAdded::dispatch($team, $newTeamMember);\n    }\n\n    /**\n     * Validate the add member operation.\n     */\n    protected function validate(Team $team, string $email, ?string $role): void\n    {\n        Validator::make([\n            'email' => $email,\n            'role' => $role,\n        ], $this->rules(), [\n            'email.exists' => __('We were unable to find a registered user with this email address.'),\n        ])->after(\n            $this->ensureUserIsNotAlreadyOnTeam($team, $email)\n        )->validateWithBag('addTeamMember');\n    }\n\n    /**\n     * Get the validation rules for adding a team member.\n     *\n     * @return array<string, \\Illuminate\\Contracts\\Validation\\Rule|array|string>\n     */\n    protected function rules(): array\n    {\n        return array_filter([\n            'email' => ['required', 'email', 'exists:users'],\n            'role' => Jetstream::hasRoles()\n                            ? ['required', 'string', new Role]\n                            : null,\n        ]);\n    }\n\n    /**\n     * Ensure that the user is not already on the team.\n     */\n    protected function ensureUserIsNotAlreadyOnTeam(Team $team, string $email): Closure\n    {\n        return function ($validator) use ($team, $email) {\n            $validator->errors()->addIf(\n                $team->hasUserWithEmail($email),\n                'email',\n                __('This user already belongs to the team.')\n            );\n        };\n    }\n}"
}
,
{
  "name": "CreateTeam",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Gate;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Laravel\\Jetstream\\Contracts\\CreatesTeams;\nuse Laravel\\Jetstream\\Events\\AddingTeam;\nuse Laravel\\Jetstream\\Jetstream;\n\nclass CreateTeam implements CreatesTeams\n{\n    /**\n     * Validate and create a new team for the given user.\n     *\n     * @param  array<string, string>  $input\n     */\n    public function create(User $user, array $input): Team\n    {\n        Gate::forUser($user)->authorize('create', Jetstream::newTeamModel());\n\n        Validator::make($input, [\n            'name' => ['required', 'string', 'max:255'],\n        ])->validateWithBag('createTeam');\n\n        AddingTeam::dispatch($user);\n\n        $user->switchTeam($team = $user->ownedTeams()->create([\n            'name' => $input['name'],\n            'personal_team' => false,\n        ]));\n\n        return $team;\n    }\n}"
}
,
{
  "name": "DeleteTeam",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse Laravel\\Jetstream\\Contracts\\DeletesTeams;\n\nclass DeleteTeam implements DeletesTeams\n{\n    /**\n     * Delete the given team.\n     */\n    public function delete(Team $team): void\n    {\n        $team->purge();\n    }\n}"
}
,
{
  "name": "DeleteUser",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\DB;\nuse Laravel\\Jetstream\\Contracts\\DeletesTeams;\nuse Laravel\\Jetstream\\Contracts\\DeletesUsers;\n\nclass DeleteUser implements DeletesUsers\n{\n    /**\n     * Create a new action instance.\n     */\n    public function __construct(protected DeletesTeams $deletesTeams)\n    {\n    }\n\n    /**\n     * Delete the given user.\n     */\n    public function delete(User $user): void\n    {\n        DB::transaction(function () use ($user) {\n            $this->deleteTeams($user);\n            $user->deleteProfilePhoto();\n            $user->tokens->each->delete();\n            $user->delete();\n        });\n    }\n\n    /**\n     * Delete the teams and team associations attached to the user.\n     */\n    protected function deleteTeams(User $user): void\n    {\n        $user->teams()->detach();\n\n        $user->ownedTeams->each(function (Team $team) {\n            $this->deletesTeams->delete($team);\n        });\n    }\n}"
}
,
{
  "name": "InviteTeamMember",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Closure;\nuse Illuminate\\Database\\Query\\Builder;\nuse Illuminate\\Support\\Facades\\Gate;\nuse Illuminate\\Support\\Facades\\Mail;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Illuminate\\Validation\\Rule;\nuse Laravel\\Jetstream\\Contracts\\InvitesTeamMembers;\nuse Laravel\\Jetstream\\Events\\InvitingTeamMember;\nuse Laravel\\Jetstream\\Jetstream;\nuse Laravel\\Jetstream\\Mail\\TeamInvitation;\nuse Laravel\\Jetstream\\Rules\\Role;\n\nclass InviteTeamMember implements InvitesTeamMembers\n{\n    /**\n     * Invite a new team member to the given team.\n     */\n    public function invite(User $user, Team $team, string $email, ?string $role = null): void\n    {\n        Gate::forUser($user)->authorize('addTeamMember', $team);\n\n        $this->validate($team, $email, $role);\n\n        InvitingTeamMember::dispatch($team, $email, $role);\n\n        $invitation = $team->teamInvitations()->create([\n            'email' => $email,\n            'role' => $role,\n        ]);\n\n        Mail::to($email)->send(new TeamInvitation($invitation));\n    }\n\n    /**\n     * Validate the invite member operation.\n     */\n    protected function validate(Team $team, string $email, ?string $role): void\n    {\n        Validator::make([\n            'email' => $email,\n            'role' => $role,\n        ], $this->rules($team), [\n            'email.unique' => __('This user has already been invited to the team.'),\n        ])->after(\n            $this->ensureUserIsNotAlreadyOnTeam($team, $email)\n        )->validateWithBag('addTeamMember');\n    }\n\n    /**\n     * Get the validation rules for inviting a team member.\n     *\n     * @return array<string, \\Illuminate\\Contracts\\Validation\\Rule|array|string>\n     */\n    protected function rules(Team $team): array\n    {\n        return array_filter([\n            'email' => [\n                'required', 'email',\n                Rule::unique(Jetstream::teamInvitationModel())->where(function (Builder $query) use ($team) {\n                    $query->where('team_id', $team->id);\n                }),\n            ],\n            'role' => Jetstream::hasRoles()\n                            ? ['required', 'string', new Role]\n                            : null,\n        ]);\n    }\n\n    /**\n     * Ensure that the user is not already on the team.\n     */\n    protected function ensureUserIsNotAlreadyOnTeam(Team $team, string $email): Closure\n    {\n        return function ($validator) use ($team, $email) {\n            $validator->errors()->addIf(\n                $team->hasUserWithEmail($email),\n                'email',\n                __('This user already belongs to the team.')\n            );\n        };\n    }\n}"
}
,
{
  "name": "RemoveTeamMember",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Illuminate\\Auth\\Access\\AuthorizationException;\nuse Illuminate\\Support\\Facades\\Gate;\nuse Illuminate\\Validation\\ValidationException;\nuse Laravel\\Jetstream\\Contracts\\RemovesTeamMembers;\nuse Laravel\\Jetstream\\Events\\TeamMemberRemoved;\n\nclass RemoveTeamMember implements RemovesTeamMembers\n{\n    /**\n     * Remove the team member from the given team.\n     */\n    public function remove(User $user, Team $team, User $teamMember): void\n    {\n        $this->authorize($user, $team, $teamMember);\n\n        $this->ensureUserDoesNotOwnTeam($teamMember, $team);\n\n        $team->removeUser($teamMember);\n\n        TeamMemberRemoved::dispatch($team, $teamMember);\n    }\n\n    /**\n     * Authorize that the user can remove the team member.\n     */\n    protected function authorize(User $user, Team $team, User $teamMember): void\n    {\n        if (! Gate::forUser($user)->check('removeTeamMember', $team) &&\n            $user->id !== $teamMember->id) {\n            throw new AuthorizationException;\n        }\n    }\n\n    /**\n     * Ensure that the currently authenticated user does not own the team.\n     */\n    protected function ensureUserDoesNotOwnTeam(User $teamMember, Team $team): void\n    {\n        if ($teamMember->id === $team->owner->id) {\n            throw ValidationException::withMessages([\n                'team' => [__('You may not leave a team that you created.')],\n            ])->errorBag('removeTeamMember');\n        }\n    }\n}"
}
,
{
  "name": "UpdateTeamName",
  "code": "<?php\n\nnamespace App\\Actions\\Jetstream;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Gate;\nuse Illuminate\\Support\\Facades\\Validator;\nuse Laravel\\Jetstream\\Contracts\\UpdatesTeamNames;\n\nclass UpdateTeamName implements UpdatesTeamNames\n{\n    /**\n     * Validate and update the given team's name.\n     *\n     * @param  array<string, string>  $input\n     */\n    public function update(User $user, Team $team, array $input): void\n    {\n        Gate::forUser($user)->authorize('update', $team);\n\n        Validator::make($input, [\n            'name' => ['required', 'string', 'max:255'],\n        ])->validateWithBag('updateTeamName');\n\n        $team->forceFill([\n            'name' => $input['name'],\n        ])->save();\n    }\n}"
}
,
{
  "name": "EGIImageCast",
  "code": "<?php\n\nnamespace App\\Casts;\n\nuse App\\Services\\EGIImageService;\nuse Illuminate\\Contracts\\Database\\Eloquent\\CastsAttributes;\nuse Illuminate\\Database\\Eloquent\\Model;\n\n/**\n * Class EGIImageCast\n *\n * Custom cast to transform image filenames into full URLs using EGIImageService.\n */\nclass EGIImageCast implements CastsAttributes\n{\n    /**\n     * Cast the given value to an image URL.\n     *\n     * @param  Model  $model\n     * @param  string $key\n     * @param  mixed  $value\n     * @param  array  $attributes\n     * @return string|null\n     */\n    public function get($model, string $key, $value, array $attributes)\n    {\n        if (!$value) {\n            return null;\n        }\n\n        // Determine the path key based on the field name.\n        $pathKey = match ($key) {\n            'image_banner' => 'head.banner',\n            'image_card'   => 'head.card',\n            'image_avatar' => 'head.avatar',\n            'image_EGI'    => 'head.EGI_asset',\n            default        => 'head.root',\n        };\n\n        // Retrieve the image URL using EGIImageService.\n        return EGIImageService::getCachedEGIImagePath(\n            $model->id,\n            $value,\n            $model->is_published,\n            null,\n            $pathKey\n        );\n    }\n\n    /**\n     * Prepare the given value for storage (no transformation).\n     *\n     * @param  Model  $model\n     * @param  string $key\n     * @param  mixed  $value\n     * @param  array  $attributes\n     * @return mixed\n     */\n    public function set($model, string $key, $value, array $attributes)\n    {\n        // Return the value as is for storage.\n        return $value;\n    }\n}"
}
,
{
  "name": "NotificationHandlerInterface",
  "code": "<?php\n\nnamespace App\\Contracts;\n\nuse Illuminate\\Notifications\\DatabaseNotification;\n\ninterface NotificationHandlerInterface\n{\n    public function handle(DatabaseNotification $notification, string $action);\n}"
}
,
{
  "name": "ProposalHandlerInterface",
  "code": "<?php\n\nnamespace App\\Contracts;\n\ninterface ProposalHandlerInterface\n{\n    /**\n     * Gestisce il declino di una proposta.\n     *\n     * @param int $proposalId\n     * @param string $reason\n     * @return void\n     */\n    public function decline(int $proposalId, string $reason): void;\n}"
}
,
{
  "name": "RoleController",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Http\\Controllers\\Admin;\n\nuse App\\Http\\Controllers\\Controller;\nuse App\\Models\\User;\nuse Illuminate\\Contracts\\View\\View;\nuse Illuminate\\Http\\RedirectResponse;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Redirect;\nuse Spatie\\Permission\\Models\\Permission;\nuse Spatie\\Permission\\Models\\Role;\n\nclass RoleController extends Controller\n{\n    public function __construct()\n    {\n        // Sposta il middleware nella definizione delle rotte\n    }\n\n    public function index(): View\n    {\n\n        $roles = Role::with('permissions')->get();\n        Log::info('Roles: ' . $roles);\n        return view('admin.roles.index', compact('roles'));\n    }\n\n    public function create(): View\n    {\n        $permissions = Permission::all();\n        return view('admin.roles.create', compact('permissions'));\n    }\n\n    public function store(Request $request): RedirectResponse\n    {\n        $validated = $request->validate([\n            'name' => ['required', 'string', 'max:255', 'unique:roles'],\n            'permissions' => ['required', 'array'],\n            'permissions.*' => ['exists:permissions,id'],\n        ]);\n\n        $role = Role::create(['name' => $validated['name']]);\n\n        $permissionNames = $this->getPermissionNames($validated['permissions']);\n        $role->syncPermissions($permissionNames);\n\n        return Redirect::route('admin.roles.index')\n            ->with('success', 'Role created successfully.');\n    }\n\n    public function edit(Role $role): View\n    {\n        $permissions = Permission::all();\n        return view('admin.roles.edit', compact('role', 'permissions'));\n    }\n\n    public function update(Request $request, Role $role): RedirectResponse\n    {\n        $validated = $request->validate([\n            'name' => ['required', 'string', 'max:255', 'unique:roles,name,' . $role->id],\n            'permissions' => ['required', 'array'],\n            'permissions.*' => ['exists:permissions,id'],\n        ]);\n\n        $role->update(['name' => $validated['name']]);\n\n        $permissionNames = $this->getPermissionNames($validated['permissions']);\n        $role->syncPermissions($permissionNames);\n\n        return Redirect::route('admin.roles.index')\n            ->with('success', 'Role updated successfully.');\n    }\n\n    protected function getPermissionNames(array $ids): array\n    {\n        return Permission::whereIn('id', $ids)->pluck('name')->toArray();\n    }\n\n    public function showAssignRoleForm()\n    {\n        $roles = Role::all(); // Recupera tutti i ruoli dalla tabella `roles`\n        return view('admin.assign-role', compact('roles'));\n    }\n\n    public function showAssignPermissionsForm()\n    {\n        $permissions = Permission::all(); // Recupera tutti i permessi\n        return view('admin.assign-permissions', compact('permissions'));\n    }\n\n    public function assignRole(Request $request)\n    {\n        $request->validate([\n            'email' => 'required|email|exists:users,email',\n            'role' => 'required|exists:roles,name',\n        ]);\n\n        $user = User::where('email', $request->email)->firstOrFail();\n        $role = $request->role;\n\n\n        // Assegna il ruolo all'utente\n        $user->assignRole($role);\n\n        Log::info('Ruolo assegnato: ' . $role . ' a ' . $user->email);\n\n        return redirect()->back()->with('success', 'Ruolo assegnato correttamente!');\n    }\n\n    public function assignPermissions(Request $request)\n    {\n        $request->validate([\n            'email' => 'required|email|exists:users,email',\n            'permissions' => 'required|array',\n            'permissions.*' => 'exists:permissions,name',\n        ]);\n\n        $user = User::where('email', $request->email)->firstOrFail();\n        $permissions = $request->permissions;\n\n        // Assegna i permessi selezionati all'utente\n        $user->syncPermissions($permissions);\n\n        return redirect()->back()->with('success', 'Permessi assegnati correttamente!');\n    }\n}"
}
,
{
  "name": "Controller",
  "code": "<?php\n\nnamespace App\\Http\\Controllers;\n\nabstract class Controller\n{\n    //\n}"
}
,
{
  "name": "DropController",
  "code": "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\n\nclass DropController extends Controller\n{\n    //\n}"
}
,
{
  "name": "IconAdminController",
  "code": "<?php\n\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse App\\Models\\Icon;\n\nclass IconAdminController extends Controller\n{\n\n    public function __construct()\n    {\n        $this->middleware('can:manage_icons');\n    }\n\n    public function index()\n    {\n        $icons = Icon::all();\n        return view('admin.icons.index', compact('icons'));\n    }\n\n    public function edit(Icon $icon)\n    {\n        return view('admin.icons.edit', compact('icon'));\n    }\n\n    public function update(Request $request, Icon $icon)\n    {\n        $request->validate([\n            'html' => 'required|string',\n        ]);\n\n        $icon->update([\n            'html' => $request->svg,\n        ]);\n\n        return redirect()->route('admin.icons.index')->with('status', 'Icon updated successfully!');\n    }\n}"
}
,
{
  "name": "WalletController",
  "code": "<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Models\\TeamWallet;\nuse Illuminate\\Http\\Request;\n\nclass WalletController extends Controller\n{\n    public function edit(TeamWallet $wallet)\n{\n    $this->authorize('update', $wallet);\n    return view('wallets.edit', compact('wallet'));\n}\n}"
}
,
{
  "name": "Kernel",
  "code": "<?php\n\nnamespace App\\Http;\n\nuse App\\Http\\Middleware\\CheckTeamPermission;\nuse App\\Http\\Middleware\\SetLanguage;\nuse Illuminate\\Foundation\\Http\\Kernel as HttpKernel;\nuse Spatie\\Permission\\Middleware\\RoleOrPermissionMiddleware;\n\nclass Kernel extends HttpKernel\n{\n    /**\n     * The application's route middleware.\n     *\n     * These middleware may be assigned to groups or used individually.\n     *\n     * @var array\n     */\n    protected $routeMiddleware = [\n        // ... altri middleware\n        // 'team' => CheckTeamPermission::class,\n    ];\n\n    /**\n     * The application's route middleware groups.\n     *\n     * @var array\n     */\n    protected $middlewareGroups = [\n        // 'web' => [\n        //     // ... altri middleware\n        //     // \\App\\Http\\Middleware\\DisableCache::class,\n        //     SetLanguage::class,\n        //     RoleOrPermissionMiddleware::class, // Assicurati che questo sia presente\n        // ],\n    ];\n\n}"
}
,
{
  "name": "AddViewDebugInfo",
  "code": "<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Symfony\\Component\\HttpFoundation\\Response;\n\nclass AddViewDebugInfo\n{\n    public function handle(Request $request, Closure $next): Response\n    {\n        $response = $next($request);\n\n        if (!app()->environment('production') &&\n            $response instanceof Response &&\n            str_contains($response->headers->get('content-type') ?? '', 'text/html')\n        ) {\n            $content = $response->getContent();\n\n            // Aggiungi uno script per mostrare il path nella console del browser\n            $debugScript = sprintf('\n                <script>\n                    console.group(\"🔍 View Debug Info\");\n                    console.log(\n                        \"Current Route: %s\",\n                        \"%s\"\n                    );\n                    console.log(\n                        \"Current View: %s\",\n                        \"%s\"\n                    );\n                    console.groupEnd();\n                </script>\n            ',\n                request()->route()?->getName() ?? request()->path(),\n                request()->url(),\n                view()->shared('__current_view_path', 'Unknown View'),\n                request()->route()?->getActionName() ?? 'Unknown Action'\n            );\n\n            // Inserisci lo script prima della chiusura del body\n            $content = preg_replace('/<\\/body>/', $debugScript . '</body>', $content, 1);\n            $response->setContent($content);\n        }\n\n        return $response;\n    }\n}"
}
,
{
  "name": "CheckCollectionPermission",
  "code": "<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Auth;\nuse App\\Models\\Collection;\nuse Illuminate\\Support\\Facades\\Log;\nuse Spatie\\Permission\\Models\\Role;\n\nclass CheckCollectionPermission\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @param  \\Closure  $next\n     * @param  string|null  $permission\n     * @return mixed\n     */\n    public function handle(Request $request, Closure $next, $permission = null)\n    {\n        // Recupera l'utente autenticato\n        $user = Auth::user();\n\n        Log::channel('florenceegi')->info('Middleware: CheckCollectionPermission', [\n            'user_id' => $user->id,\n            'permission' => $permission,\n            'user_name' => $user->name,\n        ]);\n\n        // Verifica se la rotta è 'collections.open'\n        $rotta = $request->route()->getName();\n\n        if ($rotta === 'collections.open') {\n            // Trova tutte le collection associate all'utente tramite collection_user\n            $collections = Collection::whereHas('users', function ($query) use ($user) {\n                $query->where('user_id', $user->id);\n            })->get();\n\n            // Se esiste una sola collection, usala per il controllo\n            if ($collections->count() === 1) {\n                $collection = $collections->first();\n            } else {\n                // Se ci sono più collection, consenti l'accesso per il selettore/carousel\n                return $next($request);\n            }\n        } else {\n            // Recupera l'ID della collection dalla richiesta per le altre rotte\n            $collectionId = $request->route('id') ?? $request->route('collection');\n            $collection = Collection::find($collectionId);\n\n            // Se la collection non esiste, restituisci un errore 404\n            if (!$collection) {\n                abort(404, 'Collection non trovata.');\n            }\n        }\n\n        // Verifica se l'utente è membro della collection tramite collection_user\n        $membership = $collection->users()->where('user_id', $user->id)->first();\n\n        if (!$membership) {\n            abort(403, 'Non sei un membro della collection associata.');\n        }\n\n        // Recupera il ruolo dell'utente nella collection\n        $roleName = $membership->pivot->role;\n\n        Log::channel('florenceegi')->info('Middleware: CheckCollectionPermission', [\n            'collection_id' => $collection->id,\n            'role_name' => $roleName,\n        ]);\n\n        // Verifica se il ruolo esiste in Spatie\n        $role = Role::where('name', $roleName)->first();\n        log::channel('florenceegi')->info('Middleware: CheckCollectionPermission', [\n            'role' => $role,\n        ]);\n\n        if (!$role) {\n            abort(403, 'Ruolo non valido.');\n        }\n\n        // Verifica se il ruolo ha il permesso richiesto\n        if ($permission && !$role->hasPermissionTo($permission)) {\n            abort(403, 'Non hai i permessi necessari per eseguire questa azione.');\n        }\n\n        return $next($request);\n    }\n}"
}
,
{
  "name": "DisableCache",
  "code": "<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\n\nclass DisableCache\n{\n    public function handle(Request $request, Closure $next)\n    {\n        $response = $next($request);\n        $response->headers->set('Cache-Control', 'no-cache, no-store, must-revalidate');\n        $response->headers->set('Pragma', 'no-cache');\n        $response->headers->set('Expires', '0');\n        return $response;\n    }\n}"
}
,
{
  "name": "EncryptCookies",
  "code": "<?php\r\n\r\nnamespace App\\Http\\Middleware;\r\n\r\nuse Illuminate\\Cookie\\Middleware\\EncryptCookies as Middleware;\r\n\r\nclass EncryptCookies extends Middleware\r\n{\r\n    /**\r\n     * The names of the cookies that should not be encrypted.\r\n     *\r\n     * @var array<int, string>\r\n     */\r\n    protected $except = [\r\n        //\r\n    ];\r\n}\r"
}
,
{
  "name": "SetLanguage",
  "code": "<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\App;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Cookie;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass SetLanguage\n{\n    /**\n     * Handle an incoming request.\n     *\n     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Illuminate\\Http\\Response|\\Illuminate\\Http\\RedirectResponse)  $next\n     * @return \\Illuminate\\Http\\Response|\\Illuminate\\Http\\RedirectResponse\n     */\n    public function handle(Request $request, Closure $next)\n    {\n        // 1) Verifica se l'utente è autenticato e ha un valore 'language' nel DB\n\n        // Log::channel('florenceegi')->info('USER: '.Auth::user());\n        // Log::channel('florenceegi')->info('LINGUA CORRENTE DA DB: '.Auth::user()->language);\n\n        if (Auth::user() && Auth::user()->language) {\n            $modalita = 'DB';\n            $lang = trim(Auth::user()->language);\n            App::setLocale($lang);\n\n            // 2) Se l'utente non è autenticato o non ha una lingua impostata, verifica il cookie 'language'\n        } elseif (Cookie::has('language')) {\n            $modalita = 'COOKIE';\n            $lang = trim(Cookie::get('language'));\n            App::setLocale($lang);\n            // 3) Se nessuna delle opzioni precedenti è disponibile, usa la lingua predefinita dal file di configurazione\n        } else {\n            $modalita = 'CONFIG';\n            $lang = trim(config('app.locale'));\n            App::setLocale($lang);\n        }\n\n        session(['language__'.$modalita => App::getLocale()]);\n        // Log::channel('florenceegi')->info('LINGUA CORRENTE: '.$modalita.' '.$lang);\n\n        return $next($request);\n    }\n}"
}
,
{
  "name": "SetLocale",
  "code": "<?php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\App;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass SetLocale\n{\n    public function handle(Request $request, Closure $next)\n    {\n        // Prendi la lingua dall'utente autenticato o dalla sessione o usa quella di default\n        $locale = Auth::check() && Auth::user()->language\n            ? Auth::user()->language\n            : session('locale', config('app.locale'));\n\n        // Verifica che la lingua sia tra quelle supportate\n        if (in_array($locale, config('app.languages'))) {\n            App::setLocale($locale);\n        }\n\n        return $next($request);\n    }\n} "
}
,
{
  "name": "VerifyCsrfToken",
  "code": "<?php\r\n\r\nnamespace App\\Http\\Middleware;\r\n\r\nuse Illuminate\\Foundation\\Http\\Middleware\\VerifyCsrfToken as Middleware;\r\n\r\nclass VerifyCsrfToken extends Middleware\r\n{\r\n    /**\r\n     * The URIs that should be excluded from CSRF verification.\r\n     *\r\n     * @var array<int, string>\r\n     */\r\n    protected $except = [\r\n        //\r\n    ];\r\n}\r"
}
,
{
  "name": "CollectionResource",
  "code": "<?php\n\nnamespace App\\Http\\Resources;\n\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Http\\Resources\\Json\\JsonResource;\n\nclass CollectionResource extends JsonResource\n{\n    /**\n     * Trasforma la risorsa in un array.\n     *\n     * @param  \\Illuminate\\Http\\Request  $request\n     * @return array\n     */\n    public function toArray($request)\n    {\n        return [\n            'id' => $this->id,\n            'creator_id' => $this->creator_id,\n            'owner_id' => $this->owner_id,\n            'epp_id' => $this->epp_id,\n            'type' => $this->type,\n            'is_published' => $this->is_published,\n            'collection_name' => $this->collection_name,\n            'position' => $this->position,\n            'EGI_number' => $this->EGI_number,\n            'floor_price' => $this->floor_price,\n            'description' => $this->description,\n            'url_collection_site' => $this->url_collection_site,\n            'image_banner' => $this->path_image_banner,\n            'image_card' => $this->path_image_card,\n            'image_avatar' => $this->path_image_avatar,\n        ];\n    }\n}"
}
,
{
  "name": "CollectionCarousel",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse Livewire\\Component;\nuse App\\Models\\Collection;\nuse App\\Repositories\\IconRepository;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass CollectionCarousel extends Component\n{\n    public $collections;\n    public $activeSlide = 0;\n    protected $iconRepository;\n\n    public function boot(IconRepository $iconRepository)\n    {\n        $this->iconRepository = $iconRepository;\n    }\n\n    public function mount()\n    {\n\n        $team_id = Auth::user()->currentTeam->id;\n        $this->collections = Collection::where('team_id', $team_id)->get();\n\n        Log::channel('florenceegi')->info('Collections for team', [\n            'team_id' => $team_id,\n            'collections' => $this->collections,\n        ]);\n\n    }\n\n    public function nextSlide()\n    {\n        $this->activeSlide = ($this->activeSlide + 1) % count($this->collections);\n    }\n\n    public function prevSlide()\n    {\n        $this->activeSlide = ($this->activeSlide - 1 + count($this->collections)) % count($this->collections);\n    }\n\n    public function edit($id)\n    {\n        // Implementa la logica per modificare la collezione\n    }\n\n    public function delete($id)\n    {\n        // Implementa la logica per eliminare la collezione\n    }\n\n    public function render()\n    {\n        $iconHtml = $this->iconRepository->getIcon('camera', 'elegant', '');\n        return view('livewire.collections.collection-carousel', compact('iconHtml'));\n    }\n}"
}
,
{
  "name": "SaveCollectionTraits",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Helpers\\FileHelper;\nuse App\\Livewire\\Traits\\HandlesCollectionUpdate;\nuse App\\Models\\Collection;\nuse App\\Models\\Team;\nuse App\\Models\\TeamUser;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\On;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\Validate;\nuse App\\Traits\\SaveCollectionTraits;\n\n\n/**\n * Class CollectionEdit\n * @package App\\Livewire\\Collections\n * NOTA BENE: il metodo Save è all'interno del trait SaveCollectionTraits\n */\n\nclass CollectionEdit extends Component\n{\n    use WithFileUploads, SaveCollectionTraits;\n\n    #[Validate('required|string|max:255')]\n    public $collection_name;\n\n    #[Validate('required|string')]\n    public $type;\n\n    #[Validate('nullable|integer')]\n    public $position;\n\n    #[Validate('nullable|integer')]\n    public $EGI_number;\n\n    #[Validate('nullable|numeric')]\n    public $floor_price;\n\n    #[Validate('nullable|string')]\n    public $description;\n\n    #[Validate('nullable|string')]\n    public $url_collection_site;\n\n    #[Validate('nullable|boolean')]\n    public $is_published;\n\n    public $collections;\n\n    public $collection =[];\n\n    public $model_collection = null;\n\n    public $log;\n\n    public $collectionId;\n\n    public $teamUsers;\n\n    public $teamId;\n\n    public function mount($id = null)\n    {\n\n        $this->collectionId = $id;\n        $collection = Collection::findOrFail($this->collectionId);\n\n        Log::channel('florenceegi')->info('CollectionEdit:mount', ['collection' => $collection]);\n\n        $this->collection_name = $collection->collection_name;\n        $this->type = $collection->type;\n        $this->position = $collection->position;\n        $this->EGI_number = $collection->EGI_number;\n        $this->floor_price = $collection->floor_price;\n        $this->description = $collection->description;\n        $this->url_collection_site = $collection->url_collection_site;\n        $this->is_published = $collection->is_published;\n\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.collection-manager', [\n            'userId' => Auth::id(),\n            'collectionId' => $this->collectionId,\n        ]);\n    }\n\n}"
}
,
{
  "name": "CollectionEdit",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Helpers\\FileHelper;\nuse App\\Livewire\\Traits\\HandlesCollectionUpdate;\nuse App\\Models\\Collection;\nuse App\\Models\\Team;\nuse App\\Models\\TeamUser;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\On;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\Validate;\nuse App\\Traits\\SaveCollectionTraits;\n\n\n/**\n * Class CollectionEdit\n * @package App\\Livewire\\Collections\n * NOTA BENE: il metodo Save è all'interno del trait SaveCollectionTraits\n */\n\nclass CollectionEdit extends Component\n{\n    use WithFileUploads, SaveCollectionTraits;\n\n    #[Validate('required|string|max:255')]\n    public $collection_name;\n\n    #[Validate('required|string')]\n    public $type;\n\n    #[Validate('nullable|integer')]\n    public $position;\n\n    #[Validate('nullable|integer')]\n    public $EGI_number;\n\n    #[Validate('nullable|numeric')]\n    public $floor_price;\n\n    #[Validate('nullable|string')]\n    public $description;\n\n    #[Validate('nullable|string')]\n    public $url_collection_site;\n\n    #[Validate('nullable|boolean')]\n    public $is_published;\n\n    public $collections;\n\n    public $collection =[];\n\n    public $model_collection = null;\n\n    public $log;\n\n    public $collectionId;\n\n    public $teamUsers;\n\n    public $teamId;\n\n    public function mount($id = null)\n    {\n\n        $this->collectionId = $id;\n        $collection = Collection::findOrFail($this->collectionId);\n\n        Log::channel('florenceegi')->info('CollectionEdit:mount', ['collection' => $collection]);\n\n        $this->collection_name = $collection->collection_name;\n        $this->type = $collection->type;\n        $this->position = $collection->position;\n        $this->EGI_number = $collection->EGI_number;\n        $this->floor_price = $collection->floor_price;\n        $this->description = $collection->description;\n        $this->url_collection_site = $collection->url_collection_site;\n        $this->is_published = $collection->is_published;\n\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.collection-manager', [\n            'userId' => Auth::id(),\n            'collectionId' => $this->collectionId,\n        ]);\n    }\n\n}"
}
,
{
  "name": "SaveCollectionTraits",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Repositories\\IconRepository;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse Livewire\\Features\\SupportFileUploads\\WithFileUploads;\nuse App\\Traits\\SaveCollectionTraits;\n\n/**\n * Class CollectionEdit\n * @package App\\Livewire\\Collections\n * NOTA BENE: il metodo Save è all'interno del trait SaveCollectionTraits\n */\n\nclass CollectionOpen extends Component\n{\n    use WithFileUploads, SaveCollectionTraits; // Usa il nuovo trait\n\n    #[Validate('required|string|max:255')]\n    public $collection_name;\n\n    #[Validate('required|string')]\n    public $type;\n\n    #[Validate('nullable|integer')]\n    public $position;\n\n    #[Validate('nullable|integer')]\n    public $EGI_number;\n\n    #[Validate('nullable|numeric')]\n    public $floor_price;\n\n    #[Validate('nullable|string')]\n    public $description;\n\n    #[Validate('nullable|string')]\n    public $url_collection_site;\n\n    #[Validate('nullable|boolean')]\n    public $is_published;\n\n    public $activeSlide = 0;\n    public $collections;\n    public $collection;\n    public $noCollectionMessage = 'Non ci sono collection disponibili.';\n    protected $iconRepository;\n    protected $user;\n\n    public $collectionId;\n\n    public function boot(IconRepository $iconRepository)\n    {\n        $this->iconRepository = $iconRepository;\n    }\n\n    public function mount()\n    {\n\n        $this->collections = collect(); // Inizializza come una Collection vuota\n        $this->loadCollections();\n\n    }\n\n    public function loadCollections()\n    {\n        // Recupera l'utente autenticato\n        $this->user = Auth::user();\n\n        $user = $this->user; // Nella callback non si puù usare $this\n\n        // Recupera tutte le collection associate all'utente\n        $this->collections = Collection::whereHas('users', function ($query) use ($user) {\n            $query->where('user_id', $user->id);\n        })->get();\n\n        // Verifica se c'è una sola collection\n        if ($this->collections->count() === 1) {\n\n            Log::channel('florenceegi')->info('CollectionEdit:mount', ['collection' => $this->collection]);\n\n            $this->collection = $this->collections->first();\n\n        }\n    }\n\n    public function render()\n    {\n\n        Log::channel('florenceegi')->info('CollectionOpen', [\n            'collection' => $this->collection,\n        ]);\n\n        // Se l'utente non ha alcuna collection, mostra un messaggio di avviso\n        if (!$this->collections || $this->collections->isEmpty()) {\n            return view('livewire.collections.no-collection', [\n                'message' => $this->noCollectionMessage,\n            ]);\n        }\n\n        // Se ci sono più di una collection, mostra il carousel\n        if ($this->collections->count() > 1) {\n            $iconHtml = $this->iconRepository->getIcon('camera', 'elegant', '');\n\n            return view('livewire.collections.collection-carousel', [\n                'iconHtml' => $iconHtml,\n                'collections' => $this->collections,\n            ]);\n        }\n\n        // Se c'è una sola collection, carica i dettagli\n        $this->collectionId = $this->collection->id;\n        $this->collection_name = $this->collection->collection_name;\n        $this->type = $this->collection->type;\n        $this->position = $this->collection->position;\n        $this->EGI_number = $this->collection->EGI_number;\n        $this->floor_price = $this->collection->floor_price;\n        $this->description = $this->collection->description;\n        $this->url_collection_site = $this->collection->url_collection_site;\n        $this->is_published = $this->collection->is_published;\n\n        return view('livewire.collections.collection-manager');\n    }\n\n    // public function nextSlide()\n    // {\n    //     $this->activeSlide = ($this->activeSlide + 1) % $this->collections->count();\n    // }\n\n    // public function prevSlide()\n    // {\n    //     $this->activeSlide = ($this->activeSlide - 1 + $this->collections->count()) % $this->collections->count();\n    // }\n}"
}
,
{
  "name": "CollectionOpen",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Repositories\\IconRepository;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\Validate;\nuse Livewire\\Component;\nuse Livewire\\Features\\SupportFileUploads\\WithFileUploads;\nuse App\\Traits\\SaveCollectionTraits;\n\n/**\n * Class CollectionEdit\n * @package App\\Livewire\\Collections\n * NOTA BENE: il metodo Save è all'interno del trait SaveCollectionTraits\n */\n\nclass CollectionOpen extends Component\n{\n    use WithFileUploads, SaveCollectionTraits; // Usa il nuovo trait\n\n    #[Validate('required|string|max:255')]\n    public $collection_name;\n\n    #[Validate('required|string')]\n    public $type;\n\n    #[Validate('nullable|integer')]\n    public $position;\n\n    #[Validate('nullable|integer')]\n    public $EGI_number;\n\n    #[Validate('nullable|numeric')]\n    public $floor_price;\n\n    #[Validate('nullable|string')]\n    public $description;\n\n    #[Validate('nullable|string')]\n    public $url_collection_site;\n\n    #[Validate('nullable|boolean')]\n    public $is_published;\n\n    public $activeSlide = 0;\n    public $collections;\n    public $collection;\n    public $noCollectionMessage = 'Non ci sono collection disponibili.';\n    protected $iconRepository;\n    protected $user;\n\n    public $collectionId;\n\n    public function boot(IconRepository $iconRepository)\n    {\n        $this->iconRepository = $iconRepository;\n    }\n\n    public function mount()\n    {\n\n        $this->collections = collect(); // Inizializza come una Collection vuota\n        $this->loadCollections();\n\n    }\n\n    public function loadCollections()\n    {\n        // Recupera l'utente autenticato\n        $this->user = Auth::user();\n\n        $user = $this->user; // Nella callback non si puù usare $this\n\n        // Recupera tutte le collection associate all'utente\n        $this->collections = Collection::whereHas('users', function ($query) use ($user) {\n            $query->where('user_id', $user->id);\n        })->get();\n\n        // Verifica se c'è una sola collection\n        if ($this->collections->count() === 1) {\n\n            Log::channel('florenceegi')->info('CollectionEdit:mount', ['collection' => $this->collection]);\n\n            $this->collection = $this->collections->first();\n\n        }\n    }\n\n    public function render()\n    {\n\n        Log::channel('florenceegi')->info('CollectionOpen', [\n            'collection' => $this->collection,\n        ]);\n\n        // Se l'utente non ha alcuna collection, mostra un messaggio di avviso\n        if (!$this->collections || $this->collections->isEmpty()) {\n            return view('livewire.collections.no-collection', [\n                'message' => $this->noCollectionMessage,\n            ]);\n        }\n\n        // Se ci sono più di una collection, mostra il carousel\n        if ($this->collections->count() > 1) {\n            $iconHtml = $this->iconRepository->getIcon('camera', 'elegant', '');\n\n            return view('livewire.collections.collection-carousel', [\n                'iconHtml' => $iconHtml,\n                'collections' => $this->collections,\n            ]);\n        }\n\n        // Se c'è una sola collection, carica i dettagli\n        $this->collectionId = $this->collection->id;\n        $this->collection_name = $this->collection->collection_name;\n        $this->type = $this->collection->type;\n        $this->position = $this->collection->position;\n        $this->EGI_number = $this->collection->EGI_number;\n        $this->floor_price = $this->collection->floor_price;\n        $this->description = $this->collection->description;\n        $this->url_collection_site = $this->collection->url_collection_site;\n        $this->is_published = $this->collection->is_published;\n\n        return view('livewire.collections.collection-manager');\n    }\n\n    // public function nextSlide()\n    // {\n    //     $this->activeSlide = ($this->activeSlide + 1) % $this->collections->count();\n    // }\n\n    // public function prevSlide()\n    // {\n    //     $this->activeSlide = ($this->activeSlide - 1 + $this->collections->count()) % $this->collections->count();\n    // }\n}"
}
,
{
  "name": "CollectionUserMember",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Models\\CollectionUser;\nuse App\\Models\\Wallet;\nuse Livewire\\Component;\nuse Illuminate\\Support\\Facades\\Log;\nuse App\\Traits\\HasPermissionTrait;\n\nclass CollectionUserMember extends Component\n{\n\n    use HasPermissionTrait;\n\n    public $collectionUsers; // Lista membri del team\n    public $wallets;\n\n    public $collection;\n    public $collectionId;\n    public $collectionName;\n    public $collectionOwner; // Proprietario della collection\n    public $show = false; // Proprietà per gestire la visibilità della modale\n\n    public function mount($id)\n    {\n        Log::channel('florenceegi')->info('Collection id', [\n            'collectionId' => $id\n        ]);\n\n        $this->collectionId = $id;\n\n        // Carica la collection e i suoi dati\n        $this->loadCollectionData();\n        $this->loadTeamUsers();\n    }\n\n    public function loadCollectionData()\n    {\n        $this->collection = Collection::findOrFail($this->collectionId);\n\n        $this->collectionName = $this->collection->collection_name;\n        $this->collectionOwner = $this->collection->owner; // Assumendo che esista una relazione `owner` nel modello Collection\n    }\n\n    public function loadTeamUsers()\n    {\n        $this->collectionUsers = CollectionUser::where('collection_id', $this->collectionId)->get();\n        $this->wallets = Wallet::where('collection_id', '=', $this->collectionId)->get();\n\n        Log::channel('florenceegi')->info('CollectionUsersMembers', [\n            'collectionId' => $this->collectionId,\n            'wallets' => $this->wallets\n        ]);\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.collection-user-member');\n    }\n}"
}
,
{
  "name": "CreateCollection",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse Livewire\\Component;\nuse App\\Models\\Collection;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\Validate;\n\nclass CreateCollection extends Component\n{\n    public $collection = [\n        'creator_id' => null,\n        'type' => 'image',\n        'status' => 'draft',\n        'is_published' => false,\n        'collection_name' => null,\n        'position' => null,\n        'EGI_number' => null,\n        'floor_price' => null,\n        'description' => null,\n    ];\n\n    // Regole di validazione\n    protected $rules = [\n        'collection.creator_id' => 'required|exists:users,id',\n        'collection.collection_name' => 'required|string|max:255',\n        'collection.type' => 'required|string|in:image,e-book,audio,video',\n        'collection.position' => 'nullable|integer',\n        'collection.EGI_number' => 'nullable|integer',\n        'collection.floor_price' => 'nullable|numeric',\n        'collection.description' => 'nullable|string',\n        'collection.status' => 'nullable|string|in:draft,pending_approval,published',\n        'collection.is_published' => 'nullable|boolean',\n    ];\n\n    public function create()\n    {\n        Log::channel('florenceegi')->info('Class: CreateCollection. Method: create()');\n\n        try {\n            $this->prepareCollectionData();\n\n            $this->validate();\n\n            $collection = Collection::create($this->collection);\n\n            Log::channel('florenceegi')->info('Collection created successfully', [\n                'collection_id' => $collection->id,\n                'collection_name' => $collection->collection_name,\n            ]);\n\n            session()->flash('message', __('collection.created_successfully'));\n\n            // Associa l'utente come creator nella tabella pivot collection_user\n            $collection->users()->attach(Auth::id(), ['role' => 'creator']);\n\n            // Reset dei campi\n            $this->resetInputFields();\n\n            return redirect()->route('collections.edit', $collection->id);\n\n        } catch (\\Illuminate\\Validation\\ValidationException $e) {\n            Log::channel('florenceegi')->warning('Validation failed during collection creation', [\n                'errors' => $e->errors(),\n            ]);\n            session()->flash('error', __('collection.create_validation_error'));\n            throw $e;\n        } catch (\\Exception $e) {\n            Log::channel('florenceegi')->error('Failed to create collection', [\n                'error' => $e->getMessage(),\n            ]);\n            session()->flash('error', __('collection.creation_failed'));\n        }\n    }\n\n    private function prepareCollectionData()\n    {\n        $this->collection['creator_id'] = Auth::id();\n        $this->collection['epp_id'] = config('app.epp_id');\n        $this->collection['type'] = $this->collection['type'] ?? 'image';\n        $this->collection['status'] = 'draft';\n        $this->collection['is_published'] = false;\n        $this->collection['position'] = $this->collection['position'] ?? 1;\n        $this->collection['EGI_number'] = $this->collection['EGI_number'] ?? 1;\n        $this->collection['floor_price'] = $this->collection['floor_price'] ?? 0.0;\n    }\n\n    private function resetInputFields()\n    {\n        $this->collection = [\n            'creator_id' => null,\n            'type' => 'image',\n            'status' => 'draft',\n            'is_published' => false,\n            'collection_name' => null,\n            'position' => null,\n            'EGI_number' => null,\n            'floor_price' => null,\n            'description' => null,\n        ];\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.create-collection');\n    }\n}"
}
,
{
  "name": "EditWalletModal",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Services\\Notifications\\NotificationHandlerFactory;\nuse Illuminate\\Support\\Facades\\Notification;\nuse App\\Models\\User;\nuse App\\Models\\Wallet;\nuse App\\Models\\WalletChangeApproval;\nuse App\\Notifications\\WalletChangeRequest;\nuse App\\Notifications\\WalletChangeResponse;\nuse App\\Traits\\HasPermissionTrait;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\Attributes\\On;\nuse App\\Rules\\ValidWalletAddress;\n\nclass EditWalletModal extends Component\n{\n\n    use HasPermissionTrait;\n\n    public $walletId; // Proprietà per identificare l'utente nella collection\n    public $collectionId; // Proprietà per identificare l'utente nella collection\n    public $walletAddress;\n    public $royaltyMint;\n    public $royaltyRebind;\n    public $approverUserId;\n\n    public $mode = 'create'; // Modalità di apertura della modale\n    public $show = false; // Proprietà per gestire la visibilità della modale\n\n    public function mount($walletId = null)\n    {\n\n        // if ($this->walleId) {\n        //     $this->loadData($this->walleId);\n        // }\n    }\n\n    public function loadData()\n    {\n\n        $wallet = Wallet::findOrFail($this->walletId);\n\n        Log::channel('florenceegi')->info('Wallet', [\n            'walletId' => $this->walletId\n        ]);\n\n        $this->walletAddress = $wallet->wallet;\n        $this->royaltyMint = $wallet->royalty_mint;\n        $this->royaltyRebind = $wallet->royalty_rebind;\n    }\n\n    #[On('openHandleWallets')]\n    public function openHandleWallets($walletId)\n    {\n        $this->walletId = $walletId;\n        $this->loadData();\n        $this->show = true; // Mostra la modale\n        $this->mode = 'edit';\n    }\n\n    #[On('openForCreateNewWallets')]\n    public function openForCreateNewWallets($collectionId = null, $userId = null)\n    {\n        if ($collectionId) {\n            Log::channel('florenceegi')->info('Collection id', [\n                'collectionId' => $collectionId\n            ]);\n            $this->collectionId = $collectionId;\n            $this->approverUserId = $userId;\n        } else {\n            Log::channel('florenceegi')->info('No Collection ID provided for wallet creation.');\n        }\n\n        $this->show = true; // Mostra la modale\n        $this->mode = 'create';\n    }\n\n\n    public function closeHandleWallets()\n    {\n        $this->walletAddress = null;\n        $this->royaltyMint = null;\n        $this->royaltyRebind = null;\n        $this->show = false; // Mostra la modale\n    }\n\n    public function createNewWallet()\n    {\n        Log::channel('florenceegi')->info('createNewWallet');\n\n        $this->validate([\n            // 'walletAddress' => [\n            //     'required',\n            //     'string',\n            //     new ValidWalletAddress(),\n            // ],\n            'royaltyMint' => [\n                'nullable',\n                'numeric',\n                'min:0',\n                'max:' . config('app.creator_royalty_mint'),\n            ],\n            'royaltyRebind' => [\n                'nullable',\n                'numeric',\n                'min:0',\n                'max:' . config('app.creator_royalty_rebind'),\n            ],\n        ]);\n\n        // Trovo la collection\n        $collection = Collection::findOrFail($this->collectionId);\n        // $approverUserId = $collection->creator_id;\n\n        Log::channel('florenceegi')->info('createNewWallet PRIMA della verifica dei permessi', [\n            'collectionId' => $this->collectionId,\n            'approverUserId' => $this->approverUserId\n        ]);\n\n        // Verifica permessi per l'utente autenticato\n        if (!$this->hasPermission($collection, 'create_wallet')) {\n            session()->flash('error', __('You do not have permission to create a wallet.'));\n            return;\n        }\n\n        Log::channel('florenceegi')->info('createNewWallet DOPO della verifica dei permessi', [\n            'collectionId' => $this->collectionId,\n            'approverUserId' => $this->approverUserId\n        ]);\n\n        // Verifica e aggiorna la quota del creator\n        $this->validateAndAdjustCreatorQuota($collection, $this->royaltyMint, $this->royaltyRebind);\n\n        // Crea una proposta di wallet\n        $this->proposeNewWallet($this->collectionId, $this->approverUserId, $this->walletAddress, $this->royaltyMint, $this->royaltyRebind);\n\n        $this->show = false;\n        session()->flash('message', __('Wallet creation request sent successfully!'));\n    }\n\n    public function saveWallet()\n    {\n        $this->validate([\n            'walletAddress' => 'required|string',\n            'royaltyMint' => 'nullable|numeric|min:0|max:100',\n            'royaltyRebind' => 'nullable|numeric|min:0|max:100',\n        ]);\n\n        $wallet = Wallet::findOrFail($this->walletId);\n\n        // **Controllo dei Permessi**\n        if ($wallet->user_id !== Auth::id()) {\n            // Usa il trait per verificare i permessi sulla collection\n            $this->hasPermission($wallet->collection, 'update_wallet');\n        }\n\n        // **Validazione delle Quote**\n        $remainingMint = $this->validateCreatorModification('royalty_mint', $wallet, $this->royaltyMint);\n        $remainingRebind = $this->validateCreatorModification('royalty_rebind', $wallet, $this->royaltyRebind);\n\n        // **Gestione delle Riduzioni e Accredito all’EPP**\n        $this->handleReductionsAndEpp($wallet, $remainingMint, $remainingRebind);\n\n        // **Inserimento in wallet_change_approvals**\n        if ($wallet->user_id !== Auth::id()) {\n            $this->createWalletApproval($wallet);\n            session()->flash('message', __('The modification has been submitted for approval.'));\n            $this->show = false;\n            return;\n        }\n\n        // **Applicazione della Modifica**\n        $wallet->update([\n            'wallet' => $this->walletAddress,\n            'royalty_mint' => $this->royaltyMint,\n            'royalty_rebind' => $this->royaltyRebind,\n        ]);\n\n        $this->dispatch('collectionMemberUpdated');\n        $this->show = false;\n        session()->flash('message', __('Wallet updated successfully!'));\n    }\n\n\n    private function handleReductionsAndEpp($wallet, $remainingMint, $remainingRebind)\n    {\n        $eppWallet = Wallet::where('collection_id', $wallet->collection_id)->where('platform_role', 'EPP')->first();\n\n        if ($remainingMint < 0) {\n            $eppWallet->increment('royalty_mint', abs($remainingMint));\n        }\n\n        if ($remainingRebind < 0) {\n            $eppWallet->increment('royalty_rebind', abs($remainingRebind));\n        }\n    }\n\n    private function validateCreatorModification($type, $wallet, $newValue)\n    {\n        $maxValue = $type === 'royalty_mint' ? 70.0 : 4.5;\n        $currentSum = Wallet::where('collection_id', $wallet->collection_id)->sum($type);\n\n        $newSum = $currentSum - $wallet->$type + $newValue;\n\n        if ($newSum > $maxValue) {\n            throw new \\Exception(__('The total exceeds the maximum allowed percentage.'));\n        }\n\n        return $maxValue - $newSum;\n    }\n\n    public function validateAndAdjustCreatorQuota($collection, $newMint, $newRebind)\n    {\n\n        $creatorWallet = Wallet::where('collection_id', $collection->id)\n                            ->where('user_id', $collection->creator_id)\n                            ->first();\n\n        if (!$creatorWallet) {\n            throw new \\Exception(__('Creator wallet not found.'));\n        }\n\n        // Verifica se il creator ha abbastanza quota disponibile\n        if ($creatorWallet->royalty_mint < $newMint || $creatorWallet->royalty_rebind < $newRebind) {\n            throw new \\Exception(__('Creator does not have enough quota to allocate.'));\n        }\n\n        // Riduci la quota del creator\n        // $creatorWallet->update([\n        //     'royalty_mint' => $creatorWallet->royalty_mint - $newMint,\n        //     'royalty_rebind' => $creatorWallet->royalty_rebind - $newRebind,\n        // ]);\n    }\n\n    public function proposeNewWallet($collection, $approverUserId, $walletAddress, $mint, $rebind)\n    {\n        Log::channel('florenceegi')->info('proposeNewWallet', [\n            'approverUserId' => $approverUserId,\n        ]);\n\n        // Creazione della proposta\n        $approval = WalletChangeApproval::create([\n            'wallet_id' => null, // Perché è un nuovo wallet\n            'requested_by_user_id' => Auth::user()->id, // Chi inoltra la richiesta\n            'approver_user_id' => $approverUserId, // Chi deve approvare la richiesta\n            'change_type' => 'create',\n            'change_details' => [\n                'wallet_address' => $walletAddress,\n                'royalty_mint' => $mint,\n                'royalty_rebind' => $rebind,\n            ],\n            'status' => 'pending',\n        ]);\n\n        // Usa la factory per inviare la notifica con l'action \"proposal\"\n        $handler = NotificationHandlerFactory::getHandler(WalletChangeRequest::class);\n        $handler->handle($approval, 'proposal');\n    }\n\n    public function approveChange($approvalId)\n    {\n        $approval = WalletChangeApproval::findOrFail($approvalId);\n        $wallet = $approval->wallet;\n\n        $wallet->update($approval->change_details['new']);\n        $approval->update(['status' => 'approved']);\n\n        Notification::send($approval->requestedBy, new WalletChangeResponse($approval, 'proposal'));\n        session()->flash('message', __('The wallet change has been approved.'));\n    }\n\n    public function declineChange($approvalId, $reason = null)\n    {\n        $approval = WalletChangeApproval::findOrFail($approvalId);\n\n        $approval->update([\n            'status' => 'rejected',\n            'rejection_reason' => $reason,\n        ]);\n\n        Notification::send($approval->requestedBy, new WalletChangeResponse($approval, 'rejected'));\n        session()->flash('message', __('The wallet change has been declined.'));\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.edit-wallet-modal');\n    }\n}"
}
,
{
  "name": "per",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Services\\Notifications\\NotificationHandlerFactory;\nuse Illuminate\\Support\\Facades\\Notification;\nuse App\\Models\\User;\nuse App\\Models\\Wallet;\nuse App\\Models\\WalletChangeApproval;\nuse App\\Notifications\\WalletChangeRequest;\nuse App\\Notifications\\WalletChangeResponse;\nuse App\\Traits\\HasPermissionTrait;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\Attributes\\On;\nuse App\\Rules\\ValidWalletAddress;\n\nclass EditWalletModal extends Component\n{\n\n    use HasPermissionTrait;\n\n    public $walletId; // Proprietà per identificare l'utente nella collection\n    public $collectionId; // Proprietà per identificare l'utente nella collection\n    public $walletAddress;\n    public $royaltyMint;\n    public $royaltyRebind;\n    public $approverUserId;\n\n    public $mode = 'create'; // Modalità di apertura della modale\n    public $show = false; // Proprietà per gestire la visibilità della modale\n\n    public function mount($walletId = null)\n    {\n\n        // if ($this->walleId) {\n        //     $this->loadData($this->walleId);\n        // }\n    }\n\n    public function loadData()\n    {\n\n        $wallet = Wallet::findOrFail($this->walletId);\n\n        Log::channel('florenceegi')->info('Wallet', [\n            'walletId' => $this->walletId\n        ]);\n\n        $this->walletAddress = $wallet->wallet;\n        $this->royaltyMint = $wallet->royalty_mint;\n        $this->royaltyRebind = $wallet->royalty_rebind;\n    }\n\n    #[On('openHandleWallets')]\n    public function openHandleWallets($walletId)\n    {\n        $this->walletId = $walletId;\n        $this->loadData();\n        $this->show = true; // Mostra la modale\n        $this->mode = 'edit';\n    }\n\n    #[On('openForCreateNewWallets')]\n    public function openForCreateNewWallets($collectionId = null, $userId = null)\n    {\n        if ($collectionId) {\n            Log::channel('florenceegi')->info('Collection id', [\n                'collectionId' => $collectionId\n            ]);\n            $this->collectionId = $collectionId;\n            $this->approverUserId = $userId;\n        } else {\n            Log::channel('florenceegi')->info('No Collection ID provided for wallet creation.');\n        }\n\n        $this->show = true; // Mostra la modale\n        $this->mode = 'create';\n    }\n\n\n    public function closeHandleWallets()\n    {\n        $this->walletAddress = null;\n        $this->royaltyMint = null;\n        $this->royaltyRebind = null;\n        $this->show = false; // Mostra la modale\n    }\n\n    public function createNewWallet()\n    {\n        Log::channel('florenceegi')->info('createNewWallet');\n\n        $this->validate([\n            // 'walletAddress' => [\n            //     'required',\n            //     'string',\n            //     new ValidWalletAddress(),\n            // ],\n            'royaltyMint' => [\n                'nullable',\n                'numeric',\n                'min:0',\n                'max:' . config('app.creator_royalty_mint'),\n            ],\n            'royaltyRebind' => [\n                'nullable',\n                'numeric',\n                'min:0',\n                'max:' . config('app.creator_royalty_rebind'),\n            ],\n        ]);\n\n        // Trovo la collection\n        $collection = Collection::findOrFail($this->collectionId);\n        // $approverUserId = $collection->creator_id;\n\n        Log::channel('florenceegi')->info('createNewWallet PRIMA della verifica dei permessi', [\n            'collectionId' => $this->collectionId,\n            'approverUserId' => $this->approverUserId\n        ]);\n\n        // Verifica permessi per l'utente autenticato\n        if (!$this->hasPermission($collection, 'create_wallet')) {\n            session()->flash('error', __('You do not have permission to create a wallet.'));\n            return;\n        }\n\n        Log::channel('florenceegi')->info('createNewWallet DOPO della verifica dei permessi', [\n            'collectionId' => $this->collectionId,\n            'approverUserId' => $this->approverUserId\n        ]);\n\n        // Verifica e aggiorna la quota del creator\n        $this->validateAndAdjustCreatorQuota($collection, $this->royaltyMint, $this->royaltyRebind);\n\n        // Crea una proposta di wallet\n        $this->proposeNewWallet($this->collectionId, $this->approverUserId, $this->walletAddress, $this->royaltyMint, $this->royaltyRebind);\n\n        $this->show = false;\n        session()->flash('message', __('Wallet creation request sent successfully!'));\n    }\n\n    public function saveWallet()\n    {\n        $this->validate([\n            'walletAddress' => 'required|string',\n            'royaltyMint' => 'nullable|numeric|min:0|max:100',\n            'royaltyRebind' => 'nullable|numeric|min:0|max:100',\n        ]);\n\n        $wallet = Wallet::findOrFail($this->walletId);\n\n        // **Controllo dei Permessi**\n        if ($wallet->user_id !== Auth::id()) {\n            // Usa il trait per verificare i permessi sulla collection\n            $this->hasPermission($wallet->collection, 'update_wallet');\n        }\n\n        // **Validazione delle Quote**\n        $remainingMint = $this->validateCreatorModification('royalty_mint', $wallet, $this->royaltyMint);\n        $remainingRebind = $this->validateCreatorModification('royalty_rebind', $wallet, $this->royaltyRebind);\n\n        // **Gestione delle Riduzioni e Accredito all’EPP**\n        $this->handleReductionsAndEpp($wallet, $remainingMint, $remainingRebind);\n\n        // **Inserimento in wallet_change_approvals**\n        if ($wallet->user_id !== Auth::id()) {\n            $this->createWalletApproval($wallet);\n            session()->flash('message', __('The modification has been submitted for approval.'));\n            $this->show = false;\n            return;\n        }\n\n        // **Applicazione della Modifica**\n        $wallet->update([\n            'wallet' => $this->walletAddress,\n            'royalty_mint' => $this->royaltyMint,\n            'royalty_rebind' => $this->royaltyRebind,\n        ]);\n\n        $this->dispatch('collectionMemberUpdated');\n        $this->show = false;\n        session()->flash('message', __('Wallet updated successfully!'));\n    }\n\n\n    private function handleReductionsAndEpp($wallet, $remainingMint, $remainingRebind)\n    {\n        $eppWallet = Wallet::where('collection_id', $wallet->collection_id)->where('platform_role', 'EPP')->first();\n\n        if ($remainingMint < 0) {\n            $eppWallet->increment('royalty_mint', abs($remainingMint));\n        }\n\n        if ($remainingRebind < 0) {\n            $eppWallet->increment('royalty_rebind', abs($remainingRebind));\n        }\n    }\n\n    private function validateCreatorModification($type, $wallet, $newValue)\n    {\n        $maxValue = $type === 'royalty_mint' ? 70.0 : 4.5;\n        $currentSum = Wallet::where('collection_id', $wallet->collection_id)->sum($type);\n\n        $newSum = $currentSum - $wallet->$type + $newValue;\n\n        if ($newSum > $maxValue) {\n            throw new \\Exception(__('The total exceeds the maximum allowed percentage.'));\n        }\n\n        return $maxValue - $newSum;\n    }\n\n    public function validateAndAdjustCreatorQuota($collection, $newMint, $newRebind)\n    {\n\n        $creatorWallet = Wallet::where('collection_id', $collection->id)\n                            ->where('user_id', $collection->creator_id)\n                            ->first();\n\n        if (!$creatorWallet) {\n            throw new \\Exception(__('Creator wallet not found.'));\n        }\n\n        // Verifica se il creator ha abbastanza quota disponibile\n        if ($creatorWallet->royalty_mint < $newMint || $creatorWallet->royalty_rebind < $newRebind) {\n            throw new \\Exception(__('Creator does not have enough quota to allocate.'));\n        }\n\n        // Riduci la quota del creator\n        // $creatorWallet->update([\n        //     'royalty_mint' => $creatorWallet->royalty_mint - $newMint,\n        //     'royalty_rebind' => $creatorWallet->royalty_rebind - $newRebind,\n        // ]);\n    }\n\n    public function proposeNewWallet($collection, $approverUserId, $walletAddress, $mint, $rebind)\n    {\n        Log::channel('florenceegi')->info('proposeNewWallet', [\n            'approverUserId' => $approverUserId,\n        ]);\n\n        // Creazione della proposta\n        $approval = WalletChangeApproval::create([\n            'wallet_id' => null, // Perché è un nuovo wallet\n            'requested_by_user_id' => Auth::user()->id, // Chi inoltra la richiesta\n            'approver_user_id' => $approverUserId, // Chi deve approvare la richiesta\n            'change_type' => 'create',\n            'change_details' => [\n                'wallet_address' => $walletAddress,\n                'royalty_mint' => $mint,\n                'royalty_rebind' => $rebind,\n            ],\n            'status' => 'pending',\n        ]);\n\n        // Usa la factory per inviare la notifica con l'action \"proposal\"\n        $handler = NotificationHandlerFactory::getHandler(WalletChangeRequest::class);\n        $handler->handle($approval, 'proposal');\n    }\n\n    public function approveChange($approvalId)\n    {\n        $approval = WalletChangeApproval::findOrFail($approvalId);\n        $wallet = $approval->wallet;\n\n        $wallet->update($approval->change_details['new']);\n        $approval->update(['status' => 'approved']);\n\n        Notification::send($approval->requestedBy, new WalletChangeResponse($approval, 'proposal'));\n        session()->flash('message', __('The wallet change has been approved.'));\n    }\n\n    public function declineChange($approvalId, $reason = null)\n    {\n        $approval = WalletChangeApproval::findOrFail($approvalId);\n\n        $approval->update([\n            'status' => 'rejected',\n            'rejection_reason' => $reason,\n        ]);\n\n        Notification::send($approval->requestedBy, new WalletChangeResponse($approval, 'rejected'));\n        session()->flash('message', __('The wallet change has been declined.'));\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.edit-wallet-modal');\n    }\n}"
}
,
{
  "name": "HeadImagesManager",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Services\\EGIImageService;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\n\n/**\n * Class HeadImagesManager\n *\n * This Livewire component manages the header images (banner, card, and avatar)\n * for a specific collection. It initializes the collection and provides a render\n * method to display the associated view.\n */\nclass HeadImagesManager extends Component\n{\n    /**\n     * The collection instance associated with the header images.\n     *\n     * @var Collection\n     */\n    public $collection;\n\n    /**\n     * The unique identifier for the collection.\n     *\n     * @var int\n     */\n    public $collectionId;\n\n    /**\n     * Mount the component and initialize the collection.\n     *\n     * @param int $id The ID of the collection to be managed.\n     *\n     * @return void\n     */\n    public function mount($id)\n    {\n        // Store the collection ID passed as a parameter.\n        $this->collectionId = $id;\n\n        // Retrieve the collection from the database or fail with a 404 error if not found.\n        $this->collection = Collection::findOrFail($this->collectionId);\n    }\n\n    /**\n     * Remove the existing banner image from storage and update the database.\n     *\n     * @return void\n     */\n    public function removeImage($type)\n    {\n\n        Log::channel('florenceegi')->info('HeadImagesManager, removeImage', ['type' => $type]);\n\n\n        // Clear the image state in the component.\n        switch ($type) {\n            case 'banner':\n                $this->dispatch('bannerImageRemove');\n                break;\n            case 'card':\n                $this->dispatch('cardImageRemove');\n                break;\n            case 'EGI':\n                $this->dispatch('egiImageRemove');\n                break;\n            case 'avatar':\n                $this->dispatch('avatarImageRemove');\n                break;\n        }\n\n\n\n    }\n\n    /**\n     * Render the component's view.\n     *\n     * @return \\Illuminate\\View\\View The view associated with the component.\n     */\n    public function render()\n    {\n        // Return the Livewire view for managing head images.\n        return view('livewire.collections.head-images-manager');\n    }\n}"
}
,
{
  "name": "AvatarImageUpload",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections\\Images;\n\nuse App\\Models\\Collection;\nuse App\\Services\\EGIImageService;\nuse App\\Traits\\HasPermissionTrait;\nuse App\\Traits\\SaveCollectionTraits;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Modelable;\nuse Livewire\\Features\\SupportFileUploads\\TemporaryUploadedFile;\nuse Livewire\\Attributes\\On;\n\n/**\n * Class AvatarImageUpload\n *\n * This Livewire component manages the upload, display, and removal of\n * the avatar image associated with a specific collection.\n */\nclass AvatarImageUpload extends Component\n{\n    use WithFileUploads, HasPermissionTrait;\n\n    /**\n     * The avatar image being uploaded or managed.\n     *\n     * @var TemporaryUploadedFile|null\n     */\n    #[Modelable]\n    public $image_avatar;\n\n    /**\n     * The unique identifier for the collection.\n     *\n     * @var int\n     */\n    public $collectionId;\n\n    /**\n     * The URL of the existing avatar image.\n     *\n     * @var string|null\n     */\n    public $existingImageUrl;\n\n    /**\n     * Mount the component and initialize the collection ID.\n     *\n     * @param int $collectionId The ID of the collection.\n     *\n     * @return void\n     */\n    public function mount($collectionId)\n    {\n        // Store the collection ID passed as a parameter.\n        $this->collectionId = $collectionId;\n\n        // Load the existing avatar image.\n        $this->loadExistingImage();\n    }\n\n    /**\n     * Load the existing avatar image URL from the database.\n     *\n     * @return void\n     */\n    public function loadExistingImage()\n    {\n        // Retrieve the collection or fail with a 404 error if not found.\n        $collection = Collection::findOrFail($this->collectionId);\n\n        // Check if the collection has an avatar image.\n        if ($collection->image_avatar) {\n            // Retrieve the cached image path for the avatar.\n            // $this->existingImageUrl = EGIImageService::getCachedEGIImagePath(\n            //     $this->collectionId,\n            //     $collection->image_avatar,\n            //     $collection->is_published,\n            //     null,\n            //     'head.avatar' // PathKey for the avatar image.\n            // );\n            $this->existingImageUrl = $collection->image_avatar;\n        }\n\n    }\n\n    #[On('avatarImageRemove')]\n    public function avatarImageRemove(){\n        $this->removeImage();\n    }\n\n    /**\n     * Save the uploaded avatar image to the storage and update the database.\n     *\n     * @return void\n     */\n    public function saveImage()\n    {\n\n        $collection = Collection::findOrFail($this->collectionId);\n\n        // Verifica il permesso \"update_collection\"\n        $this->hasPermission($collection, 'update_collection_image_header');\n\n\n        try {\n            // Check if an image has been uploaded.\n            if (!$this->image_avatar) {\n                throw new \\Exception('No image to save.');\n            }\n\n            // Generate a unique filename with the 'avatar_image_' prefix.\n            $filename = 'avatar_image_' . uniqid() . '.' . $this->image_avatar->getClientOriginalExtension();\n\n            // Save the image using the EGIImageService.\n            if (!EGIImageService::saveEGIImage($this->collectionId, $filename, $this->image_avatar, 'head.avatar')) {\n                throw new \\Exception('Error saving the avatar image.');\n            }\n\n            // Retrieve the collection and update the image_avatar field.\n            $collection->image_avatar = $filename;\n            $collection->save();\n\n            // Reload the existing image URL to reflect the new upload.\n            $this->loadExistingImage();\n\n            // Clear the uploaded image from the component state.\n            $this->image_avatar = null;\n\n            // Flash a success message to the session.\n            session()->flash('success', 'Avatar image saved successfully!');\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error saving the avatar image: ' . $e->getMessage());\n            session()->flash('error', 'Error saving the avatar image.');\n        }\n    }\n\n    /**\n     * Remove the existing avatar image from storage and update the database.\n     *\n     * @return void\n     */\n    public function removeImage()\n    {\n        try {\n            // Retrieve the collection or fail if not found.\n            $collection = Collection::findOrFail($this->collectionId);\n\n            // Check if the collection has an avatar image.\n            if ($collection->image_avatar) {\n                // Remove the old image using the EGIImageService.\n                EGIImageService::removeOldImage('avatar_image_', $this->collectionId, 'head.avatar');\n\n                // Set the image_avatar field to null and save the collection.\n                $collection->image_avatar = null;\n                $collection->save();\n\n                // Clear the image state in the component.\n                $this->image_avatar = null;\n                $this->existingImageUrl = null;\n\n                // Flash a success message to the session.\n                session()->flash('success', 'Avatar image removed successfully!');\n            }\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error removing the avatar image: ' . $e->getMessage());\n            session()->flash('error', 'Error removing the avatar image.');\n        }\n    }\n\n    /**\n     * Render the component's view with the appropriate image URL.\n     *\n     * @return \\Illuminate\\View\\View The view for the avatar image upload component.\n     */\n    public function render()\n    {\n        // Determine the image URL: temporary URL if the image is in preview, otherwise the existing URL.\n        $imageUrl = ($this->image_avatar instanceof TemporaryUploadedFile)\n            ? $this->image_avatar->temporaryUrl()\n            : $this->existingImageUrl;\n\n        // Return the view with the image URL.\n        return view('livewire.collections.images.avatar-image-upload', [\n            'imageUrl' => $imageUrl,\n        ]);\n    }\n}"
}
,
{
  "name": "BannerImageUpload",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections\\Images;\n\nuse App\\Models\\Collection;\nuse App\\Services\\EGIImageService;\nuse App\\Traits\\HasPermissionTrait;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Modelable;\nuse Livewire\\Features\\SupportFileUploads\\TemporaryUploadedFile;\nuse Livewire\\Attributes\\On;\n\n/**\n * Class BannerImageUpload\n *\n * This Livewire component manages the upload, display, and removal of\n * the banner image associated with a specific collection.\n */\nclass BannerImageUpload extends Component\n{\n    use WithFileUploads, HasPermissionTrait;\n\n    /**\n     * The banner image being uploaded or managed.\n     *\n     * @var TemporaryUploadedFile|null\n     */\n    #[Modelable]\n    public $image_banner;\n\n    /**\n     * The unique identifier for the collection.\n     *\n     * @var int\n     */\n    public $collectionId;\n\n    /**\n     * The URL of the existing banner image.\n     *\n     * @var string|null\n     */\n    public $existingImageUrl;\n\n    /**\n     * Mount the component and initialize the collection ID.\n     *\n     * @param int $collectionId The ID of the collection.\n     *\n     * @return void\n     */\n    public function mount($collectionId)\n    {\n        // Store the collection ID passed as a parameter.\n        $this->collectionId = $collectionId;\n\n        // Load the existing banner image.\n        $this->loadExistingImage();\n    }\n\n    /**\n     * Load the existing banner image URL from the database.\n     *\n     * @return void\n     */\n    public function loadExistingImage()\n    {\n        // Retrieve the collection or fail with a 404 error if not found.\n        $collection = Collection::findOrFail($this->collectionId);\n\n        // Check if the collection has a banner image.\n        if ($collection->image_banner) {\n            // Retrieve the cached image path for the banner.\n            $this->existingImageUrl = EGIImageService::getCachedEGIImagePath(\n                $this->collectionId,\n                $collection->image_banner,\n                $collection->is_published,\n                null,\n                'head.banner' // PathKey for the banner image.\n            );\n            $this->existingImageUrl = $collection->image_banner;\n        }\n\n    }\n\n    /**\n     * Save the uploaded banner image to the storage and update the database.\n     *\n     * @return void\n     */\n    public function saveImage()\n    {\n\n        $collection = Collection::findOrFail($this->collectionId);\n\n        // Verifica il permesso \"update_collection\"\n        $this->hasPermission($collection, 'update_collection_image_header');\n\n        try {\n            // Check if an image has been uploaded.\n            if (!$this->image_banner) {\n                throw new \\Exception('No image to save.');\n            }\n\n            // Generate a unique filename with the 'banner_image_' prefix.\n            $filename = 'banner_image_' . uniqid() . '.' . $this->image_banner->getClientOriginalExtension();\n\n            // Save the image using the EGIImageService.\n            if (!EGIImageService::saveEGIImage($this->collectionId, $filename, $this->image_banner, 'head.banner')) {\n                throw new \\Exception('Error saving the banner image.');\n            }\n\n            // Retrieve the collection and update the image_banner field.\n            $collection->image_banner = $filename;\n            $collection->save();\n\n            // Reload the existing image URL to reflect the new upload.\n            $this->loadExistingImage();\n\n            // Clear the uploaded image from the component state.\n            $this->image_banner = null;\n\n            // Flash a success message to the session.\n            session()->flash('success', 'Banner image saved successfully!');\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error saving the banner image: ' . $e->getMessage());\n            session()->flash('error', 'Error saving the banner image.');\n        }\n    }\n\n    #[On('bannerImageRemove')]\n    public function bannerImageRemove(){\n        $this->removeImage();\n    }\n\n    /**\n     * Remove the existing banner image from storage and update the database.\n     *\n     * @return void\n     */\n    public function removeImage()\n    {\n\n        try {\n            // Retrieve the collection or fail if not found.\n            $collection = Collection::findOrFail($this->collectionId);\n\n            // Check if the collection has a banner image.\n            if ($collection->image_banner) {\n                // Remove the old image using the EGIImageService.\n                EGIImageService::removeOldImage('banner_image_', $this->collectionId, 'head.banner');\n\n                // Set the image_banner field to null and save the collection.\n                $collection->image_banner = null;\n                $collection->save();\n\n                // Clear the image state in the component.\n                $this->image_banner = null;\n                $this->existingImageUrl = null;\n\n                // Flash a success message to the session.\n                session()->flash('success', 'Banner image removed successfully!');\n            }\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error removing the banner image: ' . $e->getMessage());\n            session()->flash('error', 'Error removing the banner image.');\n        }\n    }\n\n    /**\n     * Render the component's view with the appropriate image URL.\n     *\n     * @return \\Illuminate\\View\\View The view for the banner image upload component.\n     */\n    public function render()\n    {\n        // Determine the image URL: temporary URL if the image is in preview, otherwise the existing URL.\n        $imageUrl = ($this->image_banner instanceof TemporaryUploadedFile)\n            ? $this->image_banner->temporaryUrl()\n            : $this->existingImageUrl;\n\n        // Return the view with the image URL.\n        return view('livewire.collections.images.banner-image-upload', [\n            'imageUrl' => $imageUrl,\n        ]);\n    }\n}"
}
,
{
  "name": "CardImageUpload",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections\\Images;\n\nuse App\\Models\\Collection;\nuse App\\Services\\EGIImageService;\nuse App\\Traits\\HasPermissionTrait;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Modelable;\nuse Livewire\\Features\\SupportFileUploads\\TemporaryUploadedFile;\nuse Livewire\\Attributes\\On;\n\n/**\n * Class ImageUpload\n *\n * This Livewire component manages the upload, display, and removal of\n * different types of images (card, EGI asset, or default) associated with a collection.\n */\nclass CardImageUpload extends Component\n{\n    use WithFileUploads, HasPermissionTrait;\n\n    /**\n     * The image being uploaded or managed.\n     *\n     * @var TemporaryUploadedFile|null\n     */\n    #[Modelable]\n    public $image_card;\n\n    /**\n     * The unique identifier for the collection.\n     *\n     * @var int\n     */\n    public $collectionId;\n\n    /**\n     * The URL of the existing image.\n     *\n     * @var string|null\n     */\n    public $existingImageUrl;\n\n    /**\n     * Mount the component and initialize the collection ID and image type.\n     *\n     * @param int    $collectionId The ID of the collection.\n     *\n     * @return void\n     */\n    public function mount($collectionId)\n    {\n        // Store the collection ID and image type passed as parameters.\n        $this->collectionId = $collectionId;\n\n        // Load the existing image URL.\n        $this->loadExistingImage();\n    }\n\n    /**\n     * Load the existing image URL from the database.\n     *\n     * @return void\n     */\n    public function loadExistingImage()\n    {\n        // Retrieve the collection or fail with a 404 error if not found.\n        $collection = Collection::findOrFail($this->collectionId);\n\n        // Check if the collection has an image for the specified field.\n        if ($collection->image_card) {\n            // Retrieve the cached image path using the EGIImageService.\n            $this->existingImageUrl = EGIImageService::getCachedEGIImagePath(\n                $this->collectionId,\n                $collection->image_card,\n                $collection->is_published,\n                null,\n                'head.card' // PathKey for the card image.\n            );\n\n            $this->existingImageUrl = $collection->image_card;\n        }\n    }\n\n    /**\n     * Save the uploaded image to storage and update the database.\n     *\n     * @return void\n     */\n    public function saveImage()\n    {\n\n        try {\n\n            $collection = Collection::findOrFail($this->collectionId);\n\n            // Verifica il permesso \"update_collection\"\n            $this->hasPermission($collection, 'update_collection_image_header');\n\n            // Check if an image has been uploaded.\n            if (!$this->image_card) {\n                throw new \\Exception('No image to save.');\n            }\n\n            $filename = 'card_image_' . uniqid() . '.' . $this->image_card->getClientOriginalExtension();\n\n            // Save the image using the EGIImageService.\n            if (!EGIImageService::saveEGIImage($this->collectionId, $filename, $this->image_card, 'head.card')) {\n                throw new \\Exception(\"Error saving the card image.\");\n            }\n\n            // Update the corresponding database field with the new filename.\n            $collection->image_card = $filename;\n            $collection->save();\n\n            // Reload the existing image URL to reflect the new upload.\n            $this->loadExistingImage();\n\n            // Clear the uploaded image from the component state.\n            $this->image_card = null;\n\n            // Flash a success message to the session.\n            session()->flash('success', 'card image saved successfully!');\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error saving the card image: ' . $e->getMessage());\n            session()->flash('error', 'Error saving the card image.');\n        }\n    }\n\n    #[On('cardImageRemove')]\n    public function cardImageRemove(){\n\n        $this->removeImage();\n    }\n\n    /**\n     * Remove the existing image from storage and update the database.\n     *\n     * @return void\n     */\n    public function removeImage()\n    {\n        try {\n            // Retrieve the collection or fail if not found.\n            $collection = Collection::findOrFail($this->collectionId);\n\n            // Check if the collection has an image to remove.\n            if ($collection->image_card) {\n                // Remove the old image using the EGIImageService.\n                EGIImageService::removeOldImage('card_image_', $this->collectionId, 'head.card');\n\n                // Set the image field to null and save the collection.\n                $collection->image_card = null;\n                $collection->save();\n\n                // Clear the image state in the component.\n                $this->image_card = null;\n                $this->existingImageUrl = null;\n\n                // Flash a success message to the session.\n                session()->flash('success', 'card image removed successfully!');\n            }\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error removing the card image: ' . $e->getMessage());\n            session()->flash('error', 'Error removing the card image.');\n        }\n    }\n\n    /**\n     * Render the component's view with the appropriate image URL.\n     *\n     * @return \\Illuminate\\View\\View The view for the image upload component.\n     */\n    public function render()\n    {\n        // Determine the image URL: temporary URL if the image is in preview, otherwise the existing URL.\n        $imageUrl = ($this->image_card instanceof TemporaryUploadedFile)\n            ? $this->image_card->temporaryUrl()\n            : $this->existingImageUrl;\n\n        // Return the view with the image URL.\n        return view('livewire.collections.images.card-image-upload', [\n            'imageUrl' => $imageUrl,\n        ]);\n    }\n}"
}
,
{
  "name": "EgiImageUpload",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections\\Images;\n\nuse App\\Models\\Collection;\nuse App\\Services\\EGIImageService;\nuse App\\Traits\\HasPermissionTrait;\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Modelable;\nuse Livewire\\Features\\SupportFileUploads\\TemporaryUploadedFile;\nuse Livewire\\Attributes\\On;\n\n/**\n * Class ImageUpload\n *\n * This Livewire component manages the upload, display, and removal of\n * different types of images (card, EGI asset, or default) associated with a collection.\n */\nclass EgiImageUpload extends Component\n{\n    use WithFileUploads, HasPermissionTrait;\n\n    /**\n     * The image being uploaded or managed.\n     *\n     * @var TemporaryUploadedFile|null\n     */\n    #[Modelable]\n    public $image_EGI;\n\n    /**\n     * The unique identifier for the collection.\n     *\n     * @var int\n     */\n    public $collectionId;\n\n    /**\n     * The URL of the existing image.\n     *\n     * @var string|null\n     */\n    public $existingImageUrl;\n\n    /**\n     * Mount the component and initialize the collection ID and image type.\n     *\n     * @param int    $collectionId The ID of the collection.\n     *\n     * @return void\n     */\n    public function mount($collectionId)\n    {\n        // Store the collection ID and image type passed as parameters.\n        $this->collectionId = $collectionId;\n\n        // Load the existing image URL.\n        $this->loadExistingImage();\n    }\n\n    /**\n     * Load the existing image URL from the database.\n     *\n     * @return void\n     */\n    public function loadExistingImage()\n    {\n        // Retrieve the collection or fail with a 404 error if not found.\n        $collection = Collection::findOrFail($this->collectionId);\n\n        // Check if the collection has an image for the specified field.\n        if ($collection->image_EGI) {\n            // Retrieve the cached image path using the EGIImageService.\n            $this->existingImageUrl = EGIImageService::getCachedEGIImagePath(\n                $this->collectionId,\n                $collection->image_EGI,\n                $collection->is_published,\n                null,\n                'head.EGI_asset' // PathKey for the EGI image.\n            );\n\n            $this->existingImageUrl = $collection->image_EGI;\n        }\n\n    }\n\n    /**\n     * Save the uploaded image to storage and update the database.\n     *\n     * @return void\n     */\n    public function saveImage()\n    {\n\n        Log::channel('florenceegi')->info('EgiImageUpload, saveImage');\n\n        // Save the image using the EGIImageService.\n\n        try {\n\n            $collection = Collection::findOrFail($this->collectionId);\n\n            Log::channel('florenceegi')->info('EgiImageUpload, saveImage', ['collection' => $collection]);\n\n            // Verifica il permesso \"update_collection\"\n            $this->hasPermission($collection, 'update_collection_image_header');\n\n            Log::channel('florenceegi')->info('EgiImageUpload, saveImage after permission', ['image_EGI' => $this->image_EGI]);\n\n            // Check if an image has been uploaded.\n            if (!$this->image_EGI) {\n                throw new \\Exception('No image to save.');\n            }\n\n            // Generate a unique filename with the appropriate prefix.\n            $filename = 'EGI_asset_' . uniqid() . '.' . $this->image_EGI->getClientOriginalExtension();\n\n            Log::channel('florenceegi')->info('EgiImageUpload, saveImage', ['filename' => $filename]);\n\n            // Save the image using the EGIImageService.\n            if (!EGIImageService::saveEGIImage($this->collectionId, $filename, $this->image_EGI, 'head.EGI_asset')) {\n                throw new \\Exception(\"Error saving the EGI image.\");\n            }\n\n            Log::channel('florenceegi')->info('EgiImageUpload, saveImage', ['filename' => $filename]);\n\n            // Update the corresponding database field with the new filename.\n            $collection->image_EGI = $filename;\n            $collection->save();\n\n            Log::channel('florenceegi')->info('EgiImageUpload, saveImage', ['filename' => $filename]);\n\n            // Reload the existing image URL to reflect the new upload.\n            $this->loadExistingImage();\n\n            // Clear the uploaded image from the component state.\n            $this->image_EGI = null;\n\n            // Flash a success message to the session.\n            session()->flash('success', 'EGI image saved successfully!');\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error saving the EGI image: ' . $e->getMessage());\n            session()->flash('error', 'Error saving the EGI image.');\n        }\n    }\n\n    #[On('egiImageRemove')]\n    public function egiImageRemove(){\n\n\n        $this->removeImage();\n    }\n\n    /**\n     * Remove the existing image from storage and update the database.\n     *\n     * @return void\n     */\n    public function removeImage()\n    {\n        try {\n            // Retrieve the collection or fail if not found.\n            $collection = Collection::findOrFail($this->collectionId);\n\n            // Check if the collection has an image to remove.\n            if ($collection->image_EGI) {\n                // Remove the old image using the EGIImageService.\n                EGIImageService::removeOldImage('EGI_asset_', $this->collectionId, 'head.EGI_asset');\n\n                // Set the image field to null and save the collection.\n                $collection->image_EGI = null;\n                $collection->save();\n\n                // Clear the image state in the component.\n                $this->image_EGI = null;\n                $this->existingImageUrl = null;\n\n                // Flash a success message to the session.\n                session()->flash('success', 'Egi image removed successfully!');\n            }\n        } catch (\\Exception $e) {\n            // Log the error and flash an error message to the session.\n            Log::error('Error removing the EGI image: ' . $e->getMessage());\n            session()->flash('error', 'Error removing the EGI image.');\n        }\n    }\n\n\n    /**\n     * Render the component's view with the appropriate image URL.\n     *\n     * @return \\Illuminate\\View\\View The view for the image upload component.\n     */\n    public function render()\n    {\n        // Determine the image URL: temporary URL if the image is in preview, otherwise the existing URL.\n        $imageUrl = ($this->image_EGI instanceof TemporaryUploadedFile)\n            ? $this->image_EGI->temporaryUrl()\n            : $this->existingImageUrl;\n\n        // Return the view with the image URL.\n        return view('livewire.collections.images.egi-image-upload', [\n            'imageUrl' => $imageUrl,\n        ]);\n    }\n}"
}
,
{
  "name": "InviteUserToCollectionModal",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\CollectionInvitation;\nuse App\\Models\\Collection;\nuse App\\Models\\User;\nuse App\\Notifications\\CollectionInvitationNotification;\nuse Livewire\\Component;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Notification;\nuse Livewire\\Attributes\\On;\nuse Spatie\\Permission\\Models\\Role; // Importiamo i ruoli di Spatie\n\nclass InviteUserToCollectionModal extends Component\n{\n    public $email; // Email dell'utente da invitare\n    public $role; // Ruolo dell'utente nella collection\n    public $roles; // Ruoli disponibili\n    public $collectionId; // ID della collection corrente\n    public $show = false; // Gestisce la visibilità della modale\n\n    public function mount($collectionId)\n    {\n        $this->collectionId = $collectionId;\n\n        // Carica i ruoli disponibili da Spatie\n        $this->roles = Role::pluck('name')->toArray(); // Recupera i nomi dei ruoli dalla tabella 'roles'\n    }\n\n    public function invite()\n    {\n        $this->validate([\n            'email' => 'required|email',\n            'role' => 'required|in:' . implode(',', $this->roles), // Validazione sui ruoli definiti\n        ]);\n\n        // Verifica se l'utente esiste già nel sistema\n        $user = User::where('email', $this->email)->first();\n\n        // Registra l'invito nella tabella `collection_invitations`\n        $invitation = CollectionInvitation::create([\n            'collection_id' => $this->collectionId,\n            'email' => $this->email,\n            'role' => $this->role,\n            'status' => 'pending',\n        ]);\n\n        // Invia notifica all'utente, se esiste\n        if ($user) {\n            Notification::send($user, new CollectionInvitationNotification($invitation->id));\n        }\n\n        Log::channel('florenceegi')->info('Collection Invitation Sent', [\n            'collection_id' => $this->collectionId,\n            'email' => $this->email,\n            'role' => $this->role,\n        ]);\n\n        $this->resetFields();\n        $this->show = false;\n        $this->dispatch('collection-member-updated'); // Aggiorna il genitore\n    }\n\n    #[On('openInviteModal')]\n    public function showInviteModal()\n    {\n        $this->resetFields(); // Pulisce i campi\n        $this->show = true; // Mostra la modale\n    }\n\n    public function resetFields()\n    {\n        $this->email = '';\n        $this->role = '';\n    }\n\n    public function closeModal()\n    {\n        $this->show = false;\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.invite-user-to-collection-modal');\n    }\n}"
}
,
{
  "name": "RejectModal",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse Livewire\\Component;\nuse App\\Models\\WalletChangeApproval;\n\nclass RejectModal extends Component\n{\n    public $approvalId;\n    public $rejectionReason;\n\n    protected $listeners = ['openRejectModal'];\n\n    public function openRejectModal($approvalId)\n    {\n        $this->approvalId = $approvalId;\n        $this->rejectionReason = '';\n    }\n\n    public function reject()\n    {\n        $approval = WalletChangeApproval::findOrFail($this->approvalId);\n\n        $approval->wallet->update(json_decode($approval->wallet->previous_values, true));\n        $approval->wallet->update(['approval' => 'approved']);\n        $approval->update([\n            'status' => 'rejected',\n            'rejection_reason' => $this->rejectionReason,\n            'approved_at' => now(),\n        ]);\n\n        session()->flash('message', 'Modifica rifiutata.');\n        $this->emit('changesRejected');\n    }\n\n    public function render()\n    {\n        return view('livewire.collections.reject-modal');\n    }\n}"
}
,
{
  "name": "Show",
  "code": "<?php\n\nnamespace App\\Livewire\\Collections;\n\nuse App\\Models\\Collection;\nuse App\\Models\\TeamWallet;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass Show extends Component\n{\n    public $collection = [\n        'user_id' => null,\n        'team_id' => null,\n        'type' => null,\n        'is_published' => null,\n        'collection_name' => null,\n        'position' => null,\n        'EGI_number '=> null,\n        'floor_price' => null,\n        'description' => null,\n        'url_collection_site' => null,\n        'image_banner' => '',\n        'image_card' => '',\n        'image_avatar' => '',\n    ];\n\n    public $collections;\n    public $collectionId;\n\n    public function render()\n    {\n\n        $user = Auth::user();\n\n        // Recupera la collection selezionata\n        $collection = Collection::find($this->collectionId);\n\n        // estrapola tutti gli wallets relazionati al team\n        $wallets = TeamWallet::where('team_id', $collection->team_id)->get();\n\n        // Recupera tutte le collection dell'utente connesso\n        $this->collections = Collection::where('user_id', $user->id)->get();\n        return view('livewire.collections.collection-manager',[\n            'wallets' => $wallets,\n        ]);\n    }\n}"
}
,
{
  "name": "Dashboard",
  "code": "<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\CollectionInvitation;\nuse App\\Models\\WalletChangeApproval;\nuse App\\Services\\Notifications\\NotificationHandlerFactory;\nuse Livewire\\Component;\nuse App\\Models\\Collection;\nuse App\\Models\\CollectionUser;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Attributes\\On;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass Dashboard extends Component\n{\n    public $collectionsCount;\n    public $collectionMembersCount;\n    public $notifications;\n    public $viewingHistoricalNotifications = false;\n\n    public $showHistoricalNotifications = false;\n\n    public $pendingNotifications = [];\n    public $historicalNotifications = [];\n\n    public function mount()\n    {\n        $this->loadStats();\n        $this->loadNotifications();\n    }\n\n    public function loadStats()\n    {\n        $this->collectionsCount = Collection::where('creator_id', Auth::id())->count();\n\n        $this->collectionMembersCount = CollectionUser::whereHas('collection', function ($query) {\n            $query->where('creator_id', Auth::id());\n        })\n        ->where('user_id', '!=', Auth::id())\n        ->count();\n    }\n\n\n/**\n * Questo metodo gestisce l'evento \"proposal-declined\" emesso dal metodo decline() del componente DeclineProposalModal.\n *\n * @return void\n */\n    #[On('proposal-declined')]\n    public function handleProposalDeclined()\n    {\n        // Log dell'evento per verifica\n        Log::channel('florenceegi')->info('Dashboard: proposal-declined event received.');\n\n        // Ricaricare le notifiche pendenti e storiche\n        $this->loadNotifications();\n\n        // Mostrare un messaggio di successo all'utente\n        session()->flash('message', __('The proposal was declined successfully and a notification was sent to the proposer.'));\n    }\n\n    #[On('proposal-accepted')]\n    public function handleProposalAccepted()\n    {\n        // Log dell'evento per verifica\n        Log::channel('florenceegi')->info('Dashboard: proposal-accepted event received.');\n\n        // Ricaricare le notifiche pendenti e storiche\n        $this->loadNotifications();\n\n        // Mostrare un messaggio di successo all'utente\n        session()->flash('message', __('The proposal was accepted successfully and a notification was sent to the proposer.'));\n    }\n\n    public function openDeclineModal($notification)\n    {\n        Log::channel('florenceegi')->info('Dashboard: openDeclineModal', [\n            'notification' => $notification,\n\n        ]);\n\n        $notification = [\n            'id' => $notification->id,\n            'approval_id' => $notification->approval_details->id ?? null,\n            'message' => $notification->data['message'],\n            'change_type' => $notification->approval_details->change_type ?? null,\n        ];\n        $this->dispatchBrowserEvent('open-decline-modal', $notification);\n    }\n\n    public function openAcceptModal($notification)\n    {\n        Log::channel('florenceegi')->info('Dashboard: openAcceptModal', [\n            'notification' => $notification,\n        ]);\n\n        // il listener si trova in app/Livewire/Proposals/AcceptProposalModal.php\n        $this->dispatch('open-accept-modal', $notification);\n    }\n\n    public function notificationArchive($notificationId, $action)\n    {\n        $notification = Auth::user()->notifications()->findOrFail($notificationId);\n        $notification->update([\n            'read_at' => now(),\n            'outcome' => $action,\n        ]);\n\n        $this->loadNotifications();\n    }\n\n    public function deleteNotificationAction($notificationId)\n    {\n        $notification = Auth::user()->notifications()->findOrFail($notificationId);\n        $notification->delete();\n\n        $this->loadNotifications();\n    }\n\n    // public function loadNotifications()\n    // {\n    //     $this->pendingNotifications = Auth::user()->notifications()\n    //     ->where(function ($query) {\n    //         $query->whereNull('read_at')\n    //               ->orWhere('outcome', 'pending');\n    //     })\n    //     ->orderBy('created_at', 'desc')\n    //     ->get();\n\n    //     $this->historicalNotifications = Auth::user()->notifications()\n    //         ->whereIn('outcome', ['accepted', 'declined', 'done'])\n    //         ->orderBy('created_at', 'desc')\n    //         ->get();\n\n    //     Log::channel('florenceegi')->info('Dashboard: loadNotifications', [\n    //         'pendingNotifications' => $this->pendingNotifications,\n    //         'historicalNotifications' => $this->historicalNotifications,\n    //     ]);\n\n    // }\n\n    public function loadNotifications()\n    {\n        // Notifiche in sospeso\n        $this->pendingNotifications = Auth::user()->notifications()\n            ->where(function ($query) {\n                $query->whereNull('read_at')\n                    ->orWhere('outcome', 'pending');\n            })\n            ->orderBy('created_at', 'desc')\n            ->get()\n            ->map(function ($notification) {\n                $approval = WalletChangeApproval::find($notification->data['wallet_change_approvals_id']);\n                $notification->approval_details = $approval; // Colleghiamo alla notifica i dettagli completi della proposta di wallet\n\n                return $notification;\n            });\n\n        // Notifiche storiche\n        $this->historicalNotifications = Auth::user()->notifications()\n            ->whereIn('outcome', ['accepted', 'declined', 'done'])\n            ->orderBy('created_at', 'desc')\n            ->get()\n            ->map(function ($notification) {\n                $approval = WalletChangeApproval::find($notification->data['wallet_change_approvals_id']);\n                $notification->approval_details = $approval; // Colleghiamo alla notifica i dettagli completi della proposta di wallet\n                return $notification;\n            });\n\n        // Log::channel('florenceegi')->info('Dashboard: loadNotifications', [\n        //     'pendingNotifications' => $this->pendingNotifications,\n\n        // ]);\n    }\n\n\n    public function handleNotificationAction($notificationId, $action)\n    {\n        $notification = Auth::user()->notifications()->findOrFail($notificationId);\n        $type = $notification->type;\n\n        $handler = NotificationHandlerFactory::getHandler($type);\n        $handler->handle($notification, $action);\n\n        $this->loadStats();\n        $this->loadNotifications();\n    }\n\n    public function toggleHistoricalNotifications()\n    {\n        $this->showHistoricalNotifications = !$this->showHistoricalNotifications;\n    }\n\n    public function getNotificationView($notification)\n    {\n        $notificationViews = [\n            'App\\Notifications\\WalletChangeRequest' => 'notifications.wallet-change-request',\n            'App\\Notifications\\CollectionInvitationNotification' => 'notifications.invitation',\n            'App\\Livewire\\Proposals\\ProposalDeclinedNotification' => 'notifications.proposa-declined-notification',\n        ];\n\n        return $notificationViews[$notification->type] ?? 'notifications.default';\n    }\n\n    public function render()\n    {\n        return view('livewire.dashboard', [\n            'pendingNotifications' => $this->pendingNotifications,\n            'historicalNotifications' => $this->historicalNotifications,\n        ]);\n    }\n}"
}
,
{
  "name": "LanguageSelector",
  "code": "<?php\n\nnamespace App\\Livewire;\n\nuse App\\Models\\User;\nuse Livewire\\Component;\nuse Illuminate\\Support\\Facades\\App;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Cookie;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass LanguageSelector extends Component\n{\n    public $currentLocale;\n    public $languages;\n\n    public function mount()\n    {\n        $this->languages = config('app.languages');\n\n        // Segue la stessa logica del middleware SetLanguage\n        if (Auth::check() && Auth::user()->language) {\n            // Log::channel('florenceegi')->info('language from db');\n            $this->currentLocale = trim(Auth::user()->language);\n        } elseif (Cookie::has('language')) {\n            // Log::channel('florenceegi')->info('language from cookie');\n            $this->currentLocale = trim(Cookie::get('language'));\n        } else {\n            // Log::channel('florenceegi')->info('language from config');\n            $this->currentLocale = trim(config('app.locale'));\n        }\n        // App::setLocale($this->currentLocale);\n        // session(['language' => $this->currentLocale]);\n\n        session(['language' => App::getLocale()]);\n        // Log::channel('florenceegi')->info('LINGUA CORRENTE: '.App::currentLocale());\n        // Log::channel('florenceegi')->info('LINGUA CORRENTE: '.App::getLocale());\n\n    }\n\n    public function updatedCurrentLocale($value)\n    {\n        Log::channel('florenceegi')->info('Attempting to update locale to: ' . $value);\n\n        if (array_key_exists($value, $this->languages)) {\n            $value = trim($value);\n            // Log::channel('florenceegi')->info('Locale updated to: ' . $value);\n\n            // Aggiorna il database se l'utente è autenticato\n            if (Auth::check()) {\n                /** @var User $user */\n                $user = Auth::user();\n                $user->language = $value;\n                $user->save();\n                // Log::channel('florenceegi')->info('User language updated in database: ' . $value);\n            } else {\n                Log::channel('florenceegi')->info('User is not authenticated, setting cookie for language: ' . $value);\n            }\n\n            // Imposta il cookie per gli utenti non autenticati\n            Cookie::queue('language', $value, 60 * 24 * 365); // Cookie valido per un anno\n\n            // Aggiorna la sessione e l'applicazione\n            session(['language' => $value]);\n            App::setLocale($value);\n\n            Log::channel('florenceegi')->info('Language changed to: ' . App::currentLocale());\n\n            // Ricarica la pagina per applicare la nuova lingua\n            $this->dispatch('language-changed')->self();\n            return redirect(request()->header('Referer'));\n        } else {\n            Log::channel('florenceegi')->warning('Invalid language value provided: ' . $value);\n        }\n    }\n\n    public function render()\n    {\n        return view('livewire.language-selector');\n    }\n}"
}
,
{
  "name": "Navigation",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Livewire\\Layout;\n\nuse Illuminate\\Contracts\\View\\View;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Livewire\\Component;\n\nclass Navigation extends Component\n{\n\n    public $currentTeam;\n\n    public function render(): View\n    {\n\n        $this->currentTeam = Auth::user()->currentTeam?->name ?? NESSUN_TEAM;\n\n        return view('livewire.layout.navigation', [\n            'user' => Auth::user(),\n        ]);\n    }\n}"
}
,
{
  "name": "Sidebar",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Livewire\\Layout;\n\nuse Illuminate\\Contracts\\View\\View;\nuse Livewire\\Component;\n\nuse App\\Models\\ContextHasMenu;\n\nclass Sidebar extends Component\n{\n\n    public $context;\n    public $menuItems;\n\n    public function mount($context = 'general')\n    {\n        $this->context = $context;\n        $this->menuItems = ContextHasMenu::with('barMenu')\n            ->where('context', $this->context)\n            ->get()\n            ->pluck('barMenu');\n    }\n    public function render(): View\n    {\n        return view('livewire.sidebar');\n    }\n}"
}
,
{
  "name": "PhotoUploader",
  "code": "<?php\n\nnamespace App\\Livewire;\n\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Component;\nuse Livewire\\WithFileUploads;\nuse Livewire\\Attributes\\Layout;\n\nclass PhotoUploader extends Component\n{\n    use WithFileUploads;\n\n    public $photo;\n\n    public function updatedPhoto()\n    {\n        Log::info('Foto caricata:', ['photo' => $this->photo]);\n        Log::info('File caricato:', ['name' => $this->photo->getClientOriginalName()]);\n        Log::info('Percorso temporaneo:', ['path' => $this->photo->getRealPath()]);\n        Log::info('Temporary URL:', ['url' => $this->photo->temporaryUrl()]);\n\n\n        if ($this->photo) {\n            Log::info('Temporary URL:', ['url' => $this->photo->temporaryUrl()]);\n        }\n    }\n\n    public function getTemporaryUrl()\n    {\n        try {\n            return $this->photo->temporaryUrl();\n        } catch (\\Exception $e) {\n            Log::error('Errore nel generare temporaryUrl:', ['error' => $e->getMessage()]);\n            return null;\n        }\n    }\n\n    public function save()\n    {\n        // Valida il file\n        $this->validate([\n            'photo' => 'image|max:2048', // Max 2MB\n        ]);\n\n        // Salva il file nel disco configurato (di default: \"storage/app/livewire-tmp\")\n        $path = $this->photo->store('photos', 'public');\n\n        Log::info('File salvato in:', ['path' => $path]);\n\n        // Mostra un messaggio di successo (opzionale)\n        session()->flash('message', 'Foto caricata con successo: ' . $path);\n    }\n\n    #[Layout('layouts.guest')]\n    public function render()\n    {\n        return view('livewire.photo-uploader');\n    }\n}"
}
,
{
  "name": "AcceptProposalModal",
  "code": "<?php\n\nnamespace App\\Livewire\\Proposals;\n\nuse App\\Models\\WalletChangeApproval;\n\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\On;\nuse Livewire\\Component;\n\nclass AcceptProposalModal extends Component\n{\n    public $isVisible = false;\n    public $context;\n    public $type;\n    public $walletChangeApprovalId;\n    public $reason = '';\n    public $notification;\n\n    protected $rules = [\n        'reason' => 'required|string|max:500',\n    ];\n\n    #[On('open-accept-modal')]\n    public function openAcceptModal($notification)\n    {\n\n        $this->notification = $notification;\n\n        Log::channel('florenceegi')->info('AcceptProposalModal: openModal', [\n            '$this->notification' => $notification,\n        ]);\n\n        $this->isVisible = true;\n\n    }\n\n    public function closeModal()\n    {\n        $this->isVisible = false;\n    }\n\n\n    public function accept()\n    {\n\n        Log::channel('florenceegi')->info('AcceptProposalModal: accept', [\n            'notification' =>  json_encode($this->notification),\n            'type' => $this->type,\n            'reason' => $this->reason,\n        ]);\n\n        $this->validate();\n\n        // Trova la proposta nel database\n        $proposal = WalletChangeApproval::findOrFail($this->notification['data']['wallet_change_approvals_id']);\n\n        // Aggiorna lo stato della proposta a \"accepted\" e salva la motivazione\n        $proposal->update([\n            'type' => $this->notification['data']['type'],\n            'status' => 'accepted',\n            'rejection_reason' => $this->reason,\n            'read_at' => now(),\n            'notification_id' => $this->notification['id']\n        ]);\n\n        // Aggiungo i dati alla notifica di risposta\n        $this->notification['type'] = $proposal->type;\n        $this->notification['reason'] = $this->reason;\n        $this->notification['approver_user_id'] = $proposal->approver_user_id;\n\n\n        // Crea la notifica di declino per il proponente\n        $proposal->requestedBy->notify(new ProposalAcceptedNotification($this->notification));\n\n        // Compensazione del wallet del proponente\n\n        // Nasconde la modale\n        $this->isVisible = false;\n\n        // Invia l'evento per aggiornare la dashboard\n        $this->dispatch('proposal-accepted');\n    }\n\n\n\n\n    public function render()\n    {\n        return view('livewire.proposals.decline-proposal-modal');\n    }\n}"
}
,
{
  "name": "DeclineProposalModal",
  "code": "<?php\n\nnamespace App\\Livewire\\Proposals;\n\nuse App\\Models\\WalletChangeApproval;\n\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\Attributes\\On;\nuse Livewire\\Component;\n\nclass DeclineProposalModal extends Component\n{\n    public $isVisible = false;\n    public $context;\n    public $type;\n    public $walletChangeApprovalId;\n    public $reason = '';\n    public $notification;\n\n    protected $rules = [\n        'reason' => 'required|string|max:500',\n    ];\n\n    #[On('open-decline-modal')]\n    public function openDeclineModal($notification)\n    {\n\n        $this->notification = $notification;\n\n        Log::channel('florenceegi')->info('DeclineProposalModal: openModal', [\n            '$this->notification_data' => $notification,\n        ]);\n\n        $this->isVisible = true;\n\n    }\n\n    public function closeModal()\n    {\n        $this->isVisible = false;\n    }\n\n\n    public function decline()\n    {\n\n        Log::channel('florenceegi')->info('DeclineProposalModal: decline', [\n            'notification' =>  json_encode($this->notification),\n            'type' => $this->type,\n            'reason' => $this->reason,\n        ]);\n\n        $this->validate();\n\n        // Trova la proposta nel database\n        $proposal = WalletChangeApproval::findOrFail($this->notification['data']['wallet_change_approvals_id']);\n\n        // Aggiorna lo stato della proposta a \"declined\" e salva la motivazione\n        $proposal->update([\n            'type' => $this->notification['data']['type'],\n            'status' => 'declined',\n            'rejection_reason' => $this->reason,\n            'read_at' => now(),\n            'notification_id' => $this->notification['id']\n        ]);\n\n        // Aggiungo i dati alla notifica di risposta\n        $this->notification['type'] = $proposal->type;\n        $this->notification['reason'] = $this->reason;\n        $this->notification['approver_user_id'] = $proposal->approver_user_id;\n\n\n        // Crea la notifica di declino per il proponente\n        $proposal->requestedBy->notify(new ProposalDeclinedNotification($this->notification));\n\n        // Nasconde la modale\n        $this->isVisible = false;\n\n        // Invia l'evento per aggiornare la dashboard\n        $this->dispatch('proposal-declined');\n    }\n\n\n\n\n    public function render()\n    {\n        return view('livewire.proposals.decline-proposal-modal');\n    }\n}"
}
,
{
  "name": "ProposalAcceptedNotification",
  "code": "<?php\n\nnamespace App\\Livewire\\Proposals;\n\nuse App\\Models\\Notification as NotificationModel;\nuse App\\Models\\User;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Notifications\\Notification;\nuse Illuminate\\Notifications\\Messages\\DatabaseMessage;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ProposalAcceptedNotification extends Notification\n{\n    use Queueable;\n\n    public $notification;\n    public $reason;\n\n    public function __construct(array $notification)\n    {\n        $this->notification = $notification;\n\n    }\n\n    public function via($notifiable)\n    {\n        return ['database'];\n    }\n\n    public function toDatabase($notifiable)\n    {\n\n        // Trova l'utente che ha richiesto la modifica per comporre il nominativo\n        $approver = User::find($this->notification['notifiable_id']);\n        $approver_name = $approver->name . ' ' . $approver->last_name;\n\n        Log::channel('florenceegi')->info('ProposalAcceptedNotification:toDatabase', [\n            'notification id' => $this->notification['id']\n        ]);\n\n        // Aggiorna la notifica di richiesta nel database per segnalarla come completata\n        $updated_notification = NotificationModel::find($this->notification['id']);\n\n        // Ottieni i dati JSON esistenti\n        $data = $updated_notification->data;\n\n        // Aggiungi una nuova chiave al JSON\n        $data['reason'] = $this->notification['reason'];\n\n        // Aggiorna il modello con i nuovi dati\n        $updated_notification->update([\n            'outcome' => 'accepted',\n            'read_at' => now(),\n            'data' => $data, // Salva i dati aggiornati\n        ]);\n\n        return [\n            'message' => $this->notification['data']['type'] === 'create'\n                ? __('notification.proposed_creation_new_wallet')\n                : __('notification.proposed_change_to_a_wallet'),\n            'type' => 'proposal_accepted',\n            'reason' => $this->notification['reason'],\n            'wallet_address' => $this->notification['data']['wallet_address'],\n            'royalty_mint' => $this->notification['data']['royalty_mint'],\n            'royalty_rebind' => $this->notification['data']['royalty_rebind'],\n            'wallet_change_approvals_id' => $this->notification['data']['wallet_change_approvals_id'],\n            'requested_by' => $this->notification['data']['requested_by'],\n            'approver' => $approver_name,\n            'status' => 'response', // Definisce questa notifica come una [risposta]\n            'timestamp' => now(),\n        ];\n    }\n}"
}
,
{
  "name": "ProposalDeclinedNotification",
  "code": "<?php\n\nnamespace App\\Livewire\\Proposals;\n\nuse App\\Models\\Notification as NotificationModel;\nuse App\\Models\\User;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Notifications\\Notification;\nuse Illuminate\\Notifications\\Messages\\DatabaseMessage;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ProposalDeclinedNotification extends Notification\n{\n    use Queueable;\n\n    public $notification;\n    public $reason;\n\n    public function __construct(array $notification)\n    {\n        $this->notification = $notification;\n\n    }\n\n    public function via($notifiable)\n    {\n        return ['database'];\n    }\n\n    public function toDatabase($notifiable)\n    {\n\n        // Trova l'utente che ha richiesto la modifica per comporre il nominativo\n        $approver = User::find($this->notification['notifiable_id']);\n        $approver_name = $approver->name . ' ' . $approver->last_name;\n\n        Log::channel('florenceegi')->info('ProposalDeclinedNotification:toDatabase', [\n            'notification id' => $this->notification['id']\n        ]);\n\n        // Aggiorna la notifica di richiesta nel database per segnalarla come completata\n        $updated_notification = NotificationModel::find($this->notification['id']);\n\n        // Ottieni i dati JSON esistenti\n        $data = $updated_notification->data;\n\n        // Aggiungi una nuova chiave al JSON\n        $data['reason'] = $this->notification['reason'];\n\n        // Aggiorna il modello con i nuovi dati\n        $updated_notification->update([\n            'outcome' => 'declined',\n            'read_at' => now(),\n            'data' => $data, // Salva i dati aggiornati\n        ]);\n\n        return [\n            'message' => $this->notification['data']['type'] === 'create'\n                ? __('notification.proposed_creation_new_wallet')\n                : __('notification.proposed_change_to_a_wallet'),\n            'type' => 'proposal_declined',\n            'reason' => $this->notification['reason'],\n            'wallet_address' => $this->notification['data']['wallet_address'],\n            'royalty_mint' => $this->notification['data']['royalty_mint'],\n            'royalty_rebind' => $this->notification['data']['royalty_rebind'],\n            'wallet_change_approvals_id' => $this->notification['data']['wallet_change_approvals_id'],\n            'requested_by' => $this->notification['data']['requested_by'],\n            'approver' => $approver_name,\n            'status' => 'response', // Definisce questa notifica come una [risposta]\n            'timestamp' => now(),\n        ];\n    }\n}"
}
,
{
  "name": "Sidebar",
  "code": "<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\nuse Illuminate\\Support\\Facades\\Route;\nuse App\\Services\\Menu\\ContextMenus;\nuse App\\Services\\Menu\\MenuConditionEvaluator;\nuse App\\Repositories\\IconRepository;\n\nclass Sidebar extends Component\n{\n    public $menus = [];\n    public $contextTitle = '';\n    protected $iconRepo;\n\n    public function mount()\n    {\n        $evaluator = new MenuConditionEvaluator();\n        $this->iconRepo = new IconRepository();\n\n        // Determina il contesto dalla rotta corrente\n        $currentRouteName = Route::currentRouteName();\n        $context = explode('.', $currentRouteName)[0] ?? 'dashboard';\n\n        // Imposta il titolo del contesto\n        $this->contextTitle = ucfirst($context);\n\n        // Ottieni i menu per il contesto corrente\n        $allMenus = ContextMenus::getMenusForContext($context);\n\n        // Filtra i menu in base ai permessi dell'utente\n        foreach ($allMenus as $menu) {\n            $filteredItems = array_filter($menu->items, function ($item) use ($evaluator) {\n                return $evaluator->shouldDisplay($item);\n            });\n\n            if (!empty($filteredItems)) {\n                // Converti il MenuGroup in un array associativo\n                $menuArray = [\n                    'name' => $menu->name,\n                    'icon' => $menu->icon,\n                    'permission' => $menu->permission ?? null,\n                    'items' => [],\n                ];\n\n                foreach ($filteredItems as $item) {\n                    $menuArray['items'][] = [\n                        'name' => $item->name,\n                        'route' => $item->route,\n                        'icon' => $this->iconRepo->getDefaultIcon($item->icon),\n                        'permission' => $item->permission ?? null,\n                        'children' => $item->children ?? [],\n                    ];\n                }\n\n                $this->menus[] = $menuArray;\n            }\n        }\n    }\n\n    public function render()\n    {\n        return view('livewire.sidebar');\n    }\n}"
}
,
{
  "name": "TeamManager",
  "code": "<?php\n\nnamespace App\\Livewire;\n\nuse Livewire\\Component;\n\nclass TeamManager extends Component\n{\n    public function render()\n    {\n        return view('livewire.team-manager');\n    }\n}"
}
,
{
  "name": "HandlesCollectionUpdate",
  "code": "<?php\n\nnamespace App\\Livewire\\Traits;\n\nuse App\\Services\\FileStorageService;\nuse App\\Models\\Collection;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Database\\Eloquent\\ModelNotFoundException;\nuse Illuminate\\Support\\Facades\\Auth;\n\ntrait HandlesCollectionUpdate\n{\n\n    public function collectionUpdate()\n    {\n\n        try {\n            $this->validate();\n\n            $collection = Collection::findOrFail($this->collectionId);\n\n            Log::channel('florenceegi')->info('Current collection', [\n                'collection' => json_encode($collection, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE)\n            ]);\n\n            Log::channel('florenceegi')->info('Modified collection', [\n                'collection' => json_encode($this->collection, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE)\n            ]);\n\n            $collection->update($this->collection);\n\n            session()->flash('message', __('collection.updated_successfully'));\n\n        } catch (\\Illuminate\\Validation\\ValidationException $e) {\n            Log::channel('florenceegi')->error('Validation error during update', $e->errors());\n            session()->flash('error', __('collection.update.validation_error'));\n            throw $e;\n\n        } catch (ModelNotFoundException $e) {\n            Log::channel('florenceegi')->error('Collection not found during update', ['collection_id' => $this->collectionId]);\n            session()->flash('error', __('collection.not_found'));\n\n        } catch (\\Exception $e) {\n            Log::channel('florenceegi')->error('Failed to update collection', [\n                'error' => $e->getMessage(),\n                'collection_data' => $this->collection,\n                'stack_trace' => $e->getTraceAsString(),\n            ]);\n            session()->flash('error', __('collection.save_failed'));\n        }\n    }\n\n}"
}
,
{
  "name": "AuthForms",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\Livewire\\Welcome;\n\nuse Illuminate\\Contracts\\View\\View;\nuse Livewire\\Component;\n\nclass AuthForms extends Component\n{\n    public bool $showLogin = true;\n\n    public function toggleForm(): void\n    {\n        $this->showLogin = !$this->showLogin;\n    }\n\n    public function render(): View\n    {\n        return view('livewire.welcome.auth-forms');\n    }\n}"
}
,
{
  "name": "Collection",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse App\\Casts\\EGIImageCast;\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Collection extends Model\n{\n    use HasFactory;\n    use SoftDeletes; // Gestione SoftDeletes\n\n    /**\n     * Gli attributi assegnabili in massa.\n     *\n     * @var array<int, string>\n     */\n    protected $fillable = [\n        'creator_id',\n        'owner_id',\n        'collection_name',\n        'description',\n        'type',\n        'status',\n        'is_published',\n        'image_banner',\n        'image_card',\n        'image_avatar',\n        'image_egi',\n        'url_collection_site',\n        'position',\n        'EGI_number',\n        'EGI_asset_roles',\n        'floor_price',\n        'path_image_to_ipfs',\n        'url_image_ipfs',\n        'epp_id',\n        'EGI_asset_id',\n    ];\n\n    /**\n     * Gli attributi che devono essere castati.\n     *\n     * @var array\n     */\n    protected $casts = [\n        'image_banner' => EGIImageCast::class,\n        'image_card'   => EGIImageCast::class,\n        'image_avatar' => EGIImageCast::class,\n        'image_EGI'    => EGIImageCast::class,\n        'is_published' => 'boolean',\n    ];\n\n    /**\n     * Relazione con il creator.\n     */\n    public function creator()\n    {\n        return $this->belongsTo(User::class, 'creator_id');\n    }\n\n    /**\n     * Relazione con l'owner.\n     */\n    public function owner()\n    {\n        return $this->belongsTo(User::class, 'owner_id');\n    }\n\n    /**\n     * Relazione con gli EGI.\n     */\n    public function egis()\n    {\n        return $this->hasMany(Egi::class);\n    }\n\n    /**\n     * Relazione con gli utenti tramite la tabella pivot collection_user.\n     */\n    public function users()\n    {\n        return $this->belongsToMany(User::class, 'collection_user')\n                    ->withPivot('role')\n                    ->withTimestamps();\n    }\n\n    /**\n     * Relazione con i wallet.\n     */\n    public function wallets()\n    {\n        return $this->hasMany(Wallet::class);\n    }\n\n    /**\n     * Verifica se la collection è pubblicata.\n     *\n     * @return bool\n     */\n    public function isPublished(): bool\n    {\n        return $this->status === 'published';\n    }\n\n    /**\n     * Verifica se la collection può essere pubblicata.\n     *\n     * @return bool\n     */\n    public function canBePublished(): bool\n    {\n        $pendingApprovals = WalletChangeApproval::whereHas('wallet', function ($query) {\n            $query->where('collection_id', $this->id);\n        })->where('status', 'pending')->exists();\n\n        return !$pendingApprovals && $this->status === 'draft';\n    }\n}"
}
,
{
  "name": "CollectionInvitation",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass CollectionInvitation extends Model\n{\n    use HasFactory;\n\n    /**\n     * La tabella associata al modello.\n     *\n     * @var string\n     */\n    protected $table = 'collection_invitations';\n\n    /**\n     * I campi che possono essere assegnati in massa.\n     *\n     * @var array\n     */\n    protected $fillable = [\n        'collection_id',\n        'email',\n        'role',\n        'status',\n    ];\n\n    /**\n     * Relazione con il modello Collection.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsTo\n     */\n    public function collection()\n    {\n        return $this->belongsTo(Collection::class);\n    }\n\n    /**\n     * Determina se l'invito è in sospeso.\n     *\n     * @return bool\n     */\n    public function isPending()\n    {\n        return $this->status === 'pending';\n    }\n\n    /**\n     * Determina se l'invito è stato accettato.\n     *\n     * @return bool\n     */\n    public function isAccepted()\n    {\n        return $this->status === 'accepted';\n    }\n\n    /**\n     * Determina se l'invito è stato rifiutato.\n     *\n     * @return bool\n     */\n    public function isRejected()\n    {\n        return $this->status === 'rejected';\n    }\n}"
}
,
{
  "name": "CollectionUser",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass CollectionUser extends Model\n{\n    use HasFactory;\n\n    protected $table = 'collection_user';\n\n    protected $fillable = [\n        'collection_id',\n        'user_id',\n        'role',\n        'is_owner',\n        'joined_at',\n        'removed_at',\n        'metadata',\n        'status',\n    ];\n\n    // const STATUS_PENDING = 'pending';\n    // const STATUS_ACCEPTED = 'accepted';\n    // const STATUS_REJECTED = 'rejected';\n\n    // public static function statuses()\n    // {\n    //     return [\n    //         self::STATUS_PENDING,\n    //         self::STATUS_ACCEPTED,\n    //         self::STATUS_REJECTED,\n    //     ];\n    // }\n\n    protected $casts = [\n        'is_owner' => 'boolean',\n        'joined_at' => 'datetime',\n        'removed_at' => 'datetime',\n        'metadata' => 'array',\n    ];\n\n    public function collection()\n    {\n        return $this->belongsTo(Collection::class);\n    }\n\n    public function user()\n    {\n        return $this->belongsTo(User::class);\n    }\n\n    /**\n     * Relazione con il modello Wallet.\n     * Supponendo che la tabella `wallets` abbia una colonna `collection_user_id`\n     * per identificare il wallet associato al CollectionUser.\n     */\n    public function wallet()\n    {\n        return $this->hasOne(Wallet::class, 'user_id', 'id');\n    }\n}"
}
,
{
  "name": "Egi",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse Illuminate\\Database\\Eloquent\\SoftDeletes;\n\nclass Egi extends Model\n{\n\n    use SoftDeletes;\n\n    protected $fillable = [\n        'collection_id', 'key_file', 'token_EGI', 'jsonMetadata', 'user_id',\n        'auction_id', 'owner_id', 'drop_id', 'upload_id', 'creator', 'owner_wallet',\n        'drop_title', 'title', 'description', 'extension', 'media', 'type', 'bind',\n        'paired', 'price', 'floorDropPrice', 'position', 'creation_date', 'size',\n        'dimension', 'is_published', 'mint', 'rebind', 'file_crypt', 'file_hash',\n        'file_IPFS', 'file_mime', 'status', 'is_public', 'updated_by'\n    ];\n\n    public static function boot()\n    {\n        parent::boot();\n\n        static::updated(function ($egi) {\n            $egi->audits()->create([\n                'user_id' => auth()->id(),\n                'old_values' => $egi->getOriginal(),\n                'new_values' => $egi->getChanges(),\n                'action' => 'update',\n            ]);\n        });\n    }\n\n    public function audits()\n    {\n        return $this->hasMany(EgiAudit::class);\n    }\n\n    public function collection()\n    {\n        return $this->belongsTo(Collection::class);\n    }\n}"
}
,
{
  "name": "EgiAudit",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass EgiAudit extends Model\n{\n    //\n}"
}
,
{
  "name": "Icon",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Icon extends Model\n{\n    use HasFactory;\n\n    /**\n     * The attributes that are mass assignable.\n     *\n     * @var array<int, string>\n     */\n    protected $fillable = [\n        'name',\n        'style',\n        'type',\n        'class',\n        'html',\n    ];\n\n    /**\n     * Accessor to get the full HTML for the icon.\n     *\n     * @return string\n     */\n    public function getFullHtmlAttribute(): string\n    {\n        return $this->html;\n    }\n\n    /**\n     * Mutator to sanitize the HTML input.\n     *\n     * @param string $value\n     */\n    public function setHtmlAttribute(string $value): void\n    {\n        // Optional sanitization logic if needed\n        $this->attributes['html'] = trim($value);\n    }\n}"
}
,
{
  "name": "Membership",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Laravel\\Jetstream\\Membership as JetstreamMembership;\n\nclass Membership extends JetstreamMembership\n{\n    /**\n     * Indicates if the IDs are auto-incrementing.\n     *\n     * @var bool\n     */\n    public $incrementing = true;\n}"
}
,
{
  "name": "Notification",
  "code": "<?php\n\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Model;\nuse App\\Traits\\UsesUuid;\n\nclass Notification extends Model\n{\n    use UsesUuid;\n\n    protected $fillable = [\n        'type',\n        'notifiable_type',\n        'notifiable_id',\n        'outcome',\n        'data',\n        'read_at',\n    ];\n\n    protected $casts = [\n        'data' => 'array', // Questo converte automaticamente il JSON in un array associativo\n    ];\n\n}"
}
,
{
  "name": "User",
  "code": "<?php\n\nnamespace App\\Models;\n\n// use Illuminate\\Contracts\\Auth\\MustVerifyEmail;\nuse App\\Traits\\HasTeamRoles;\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Notifications\\Notifiable;\nuse Laravel\\Fortify\\TwoFactorAuthenticatable;\nuse Laravel\\Jetstream\\HasProfilePhoto;\nuse Laravel\\Jetstream\\HasTeams;\nuse Laravel\\Sanctum\\HasApiTokens;\nuse Spatie\\Permission\\Traits\\HasRoles;\n\nclass User extends Authenticatable\n{\n    use HasApiTokens;\n    use HasRoles;\n    use Notifiable;\n\n\n    /** @use HasFactory<\\Database\\Factories\\UserFactory> */\n    use HasFactory;\n    use HasProfilePhoto;\n    use HasTeams;\n    use Notifiable;\n    use TwoFactorAuthenticatable;\n\n    /**\n     * The attributes that are mass assignable.\n     *\n     * @var array<int, string>\n     */\n    protected $fillable = [\n        'user_id',\n        'name',\n        'last_name',\n        'email',\n        'icon_style',\n        'password',\n        'language',\n        'wallet',\n        'wallet_balance',\n        'consent',\n        'bio_title',\n        'bio_story',\n        'title',\n        'job_role',\n        'username',\n        'usertype',\n        'street',\n        'city',\n        'region',\n        'state',\n        'zip',\n        'home_phone',\n        'cell_phone',\n        'work_phone',\n        'site_url',\n        'facebook',\n        'social_x',\n        'tiktok',\n        'instagram',\n        'snapchat',\n        'twitch',\n        'linkedin',\n        'discord',\n        'telegram',\n        'other',\n        'birth_date',\n        'fiscal_code',\n        'tax_id_number',\n        'doc_typo',\n        'doc_num',\n        'doc_issue_date',\n        'doc_expired_date',\n        'doc_issue_from',\n        'doc_photo_path_f',\n        'doc_photo_path_r',\n        'org_name',\n        'org_email',\n        'org_street',\n        'org_city',\n        'org_region',\n        'org_state',\n        'org_zip',\n        'org_site_url',\n        'annotation',\n        'org_phone_1',\n        'org_phone_2',\n        'org_phone_3',\n        'rea',\n        'org_fiscal_code',\n        'org_vat_number',\n        'current_team_id',\n        'profile_photo_path',\n    ];\n\n    protected $casts = [\n        'email_verified_at' => 'datetime',\n        'birth_date' => 'date',\n        'doc_issue_date' => 'date',\n        'doc_expired_date' => 'date',\n        'wallet_balance' => 'decimal:4',\n        'consent' => 'boolean',\n    ];\n\n\n    /**\n     * The attributes that should be hidden for serialization.\n     *\n     * @var array<int, string>\n     */\n    protected $hidden = [\n        'password',\n        'remember_token',\n        'two_factor_recovery_codes',\n        'two_factor_secret',\n    ];\n\n    /**\n     * The accessors to append to the model's array form.\n     *\n     * @var array<int, string>\n     */\n    protected $appends = [\n        'profile_photo_url',\n    ];\n\n    public function getIconStyleAttribute(): string\n    {\n        // Ritorna l'icon_style dall'attributo o un valore di default\n        return $this->attributes['icon_style'] ?? config('icons.default');\n    }\n\n\n    public function wallets()\n    {\n        return $this->hasMany(Wallet::class);\n    }\n\n\n    /**\n     * Get the attributes that should be cast.\n     *\n     * @return array<string, string>\n     */\n    // protected function casts(): array\n    // {\n    //     return [\n    //         'email_verified_at' => 'datetime',\n    //         'password' => 'hashed',\n    //     ];\n    // }\n}"
}
,
{
  "name": "Wallet",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass Wallet extends Model\n{\n    use HasFactory;\n\n    protected $fillable = [\n        'collection_id',\n        'user_id',\n        'wallet',\n        'royalty_mint',\n        'royalty_rebind',\n        'is_anonymous',\n        'metadata',\n    ];\n\n    protected $casts = [\n        'is_anonymous' => 'boolean',\n        'metadata' => 'array',\n    ];\n\n    public function collection()\n    {\n        return $this->belongsTo(Collection::class);\n    }\n\n    public function user()\n    {\n        return $this->belongsTo(User::class);\n    }\n\n\n}"
}
,
{
  "name": "WalletChangeApproval",
  "code": "<?php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass WalletChangeApproval extends Model\n{\n    use HasFactory;\n\n    /**\n     * La tabella associata al modello.\n     *\n     * @var string\n     */\n    protected $table = 'wallet_change_approvals';\n\n    /**\n     * Gli attributi assegnabili in massa.\n     *\n     * @var array\n     */\n    protected $fillable = [\n        'id',\n        'wallet_id',\n        'requested_by_user_id',\n        'approver_user_id',\n        'change_type',\n        'change_details',\n        'status',\n        'type', // Nuovo campo\n        'rejection_reason',\n    ];\n\n        /**\n     * The accessors to append to the model's array form.\n     *\n     * @var array<int, string>\n     */\n    protected $appends = [\n        'notification_id',\n    ];\n\n    /**\n     * Gli attributi che devono essere castati.\n     *\n     * @var array\n     */\n    protected $casts = [\n        'change_details' => 'array', // Il campo JSON viene automaticamente convertito in array\n    ];\n\n    /**\n     * Relazione con il modello Wallet.\n     */\n    public function wallet()\n    {\n        return $this->belongsTo(Wallet::class);\n    }\n\n    /**\n     * Relazione con il modello User per l'utente che ha richiesto la modifica.\n     */\n    public function requestedBy()\n    {\n        return $this->belongsTo(User::class, 'requested_by_user_id');\n    }\n\n    /**\n     * Relazione con il modello User per l'utente che approva la modifica.\n     */\n    public function approver()\n    {\n        return $this->belongsTo(User::class, 'approver_user_id');\n    }\n}"
}
,
{
  "name": "CollectionInvitationNotification",
  "code": "<?php\n\nnamespace App\\Notifications;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Notifications\\Messages\\MailMessage;\nuse Illuminate\\Notifications\\Notification;\n\nclass CollectionInvitationNotification extends Notification\n{\n    protected $invitationId;\n\n    public function __construct($invitationId)\n    {\n        $this->invitationId = $invitationId;\n    }\n\n    public function via($notifiable)\n    {\n        return ['database'];\n    }\n\n    public function toDatabase($notifiable)\n    {\n        return [\n            'message' => 'You have been invited to join a team.',\n            'invitation_id' => $this->invitationId,\n        ];\n    }\n}"
}
,
{
  "name": "WalletChangeRequest",
  "code": "<?php\n\nnamespace App\\Notifications;\n\nuse Illuminate\\Notifications\\Notification;\nuse Illuminate\\Notifications\\Messages\\DatabaseMessage;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass WalletChangeRequest extends Notification\n{\n    protected $approval; \n\n    public function __construct($approval)\n    {\n        $this->approval = $approval;\n    }\n\n    public function via($notifiable)\n    {\n        return ['database'];\n    }\n\n    public function toDatabase($notifiable)\n    {\n        Log::channel('florenceegi')->info('WalletChangeRequest:toDatabase', [\n            'notifiable' => $notifiable\n        ]);\n\n        return [\n            'message' => $this->approval->change_type === 'create'\n                ? __('A new wallet has been proposed for you.')\n                : __('A change has been requested for your wallet.'),\n            'wallet_change_approvals_id' => $this->approval->id,\n            'outcome' => 'proposal', // Sostituito \"status\" con \"outcome\"\n        ];\n    }\n}"
}
,
{
  "name": "WalletChangeResponse",
  "code": "<?php\n\n\nnamespace App\\Notifications;\n\nuse Illuminate\\Notifications\\Notification;\nuse Illuminate\\Notifications\\Messages\\DatabaseMessage;\n\nclass WalletChangeResponse extends Notification\n{\n    private $approval;\n    private $status;\n\n    public function __construct($approval, $status)\n    {\n        $this->approval = $approval;\n        $this->status = $status;\n    }\n\n    public function via($notifiable)\n    {\n        return ['database'];\n    }\n\n    public function toDatabase($notifiable)\n    {\n        return [\n            'message' => $this->status === 'approved'\n                ? __('Your wallet change has been approved.')\n                : __('Your wallet change has been declined. Reason: ') . $this->approval->rejection_reason,\n            'wallet_change_approvals_id' => $this->approval->id,\n        ];\n    }\n}"
}
,
{
  "name": "CollectionPolicy",
  "code": "<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\Collection;\nuse App\\Models\\User;\nuse Illuminate\\Auth\\Access\\Response;\n\nclass CollectionPolicy\n{\n    /**\n     * Determine whether the user can view any models.\n     */\n    public function viewAny(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can view the model.\n     */\n    public function view(User $user, Collection $collection): bool\n    {\n        return $user->can('read_collection');\n    }\n\n    /**\n     * Determine whether the user can create models.\n     */\n    public function create(User $user): bool\n    {\n        return $user->can('create_collection');\n    }\n\n    /**\n     * Determine whether the user can update the model.\n     */\n    public function update(User $user, Collection $collection): bool\n    {\n        return $user->can('update_collection');\n    }\n\n    /**\n     * Determine whether the user can delete the model.\n     */\n    public function delete(User $user, Collection $collection): bool\n    {\n        return $user->can('delete_collection');\n    }\n\n    /**\n     * Determine whether the user can restore the model.\n     */\n    public function restore(User $user, Collection $collection): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can permanently delete the model.\n     */\n    public function forceDelete(User $user, Collection $collection): bool\n    {\n        return false;\n    }\n}"
}
,
{
  "name": "EgiPolicy",
  "code": "<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\User;\nuse Illuminate\\Auth\\Access\\Response;\n\nclass EgiPolicy\n{\n    /**\n     * Determine whether the user can view any models.\n     */\n    public function viewAny(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can view the model.\n     */\n    public function view(User $user): bool\n    {\n        return $user->can('read_egi');\n    }\n\n    /**\n     * Determine whether the user can create models.\n     */\n    public function create(User $user): bool\n    {\n        return $user->can('create_egi');\n    }\n\n    /**\n     * Determine whether the user can update the model.\n     */\n    public function update(User $user): bool\n    {\n        return $user->can('update_egi');\n    }\n\n    /**\n     * Determine whether the user can delete the model.\n     */\n    public function delete(User $user): bool\n    {\n        return $user->can('delete_egi');\n    }\n\n    /**\n     * Determine whether the user can restore the model.\n     */\n    public function restore(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can permanently delete the model.\n     */\n    public function forceDelete(User $user): bool\n    {\n        return false;\n    }\n}"
}
,
{
  "name": "ProfilePolicy",
  "code": "<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\User;\nuse Illuminate\\Auth\\Access\\Response;\n\nclass ProfilePolicy\n{\n    /**\n     * Determine whether the user can view any models.\n     */\n    public function viewAny(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can view the model.\n     */\n    public function view(User $user, User $model): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can create models.\n     */\n    public function create(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can update the model.\n     */\n    public function update(User $user, User $profileOwner)\n    {\n        return $user->id === $profileOwner->id;\n    }\n    /**\n     * Determine whether the user can delete the model.\n     */\n    public function delete(User $user, User $model): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can restore the model.\n     */\n    public function restore(User $user, User $model): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can permanently delete the model.\n     */\n    public function forceDelete(User $user, User $model): bool\n    {\n        return false;\n    }\n}"
}
,
{
  "name": "TeamPolicy",
  "code": "<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\Team;\nuse App\\Models\\User;\nuse Illuminate\\Auth\\Access\\HandlesAuthorization;\n\nclass TeamPolicy\n{\n    use HandlesAuthorization;\n\n    /**\n     * Determine whether the user can view any models.\n     */\n    public function viewAny(User $user): bool\n    {\n        return true;\n    }\n\n    /**\n     * Determine whether the user can view the model.\n     */\n    public function view(User $user, Team $team): bool\n    {\n        return $user->belongsToTeam($team);\n    }\n\n    /**\n     * Determine whether the user can create models.\n     */\n    public function create(User $user): bool\n    {\n        return true;\n    }\n\n    /**\n     * Determine whether the user can update the model.\n     */\n    public function update(User $user, Team $team): bool\n    {\n        return $user->ownsTeam($team);\n    }\n\n    /**\n     * Determine whether the user can add team members.\n     */\n    public function addTeamMember(User $user, Team $team): bool\n    {\n        return $user->ownsTeam($team);\n    }\n\n    /**\n     * Determine whether the user can update team member permissions.\n     */\n    public function updateTeamMember(User $user, Team $team): bool\n    {\n        return $user->ownsTeam($team);\n    }\n\n    /**\n     * Determine whether the user can remove team members.\n     */\n    public function removeTeamMember(User $user, Team $team): bool\n    {\n        return $user->ownsTeam($team);\n    }\n\n    /**\n     * Determine whether the user can delete the model.\n     */\n    public function delete(User $user, Team $team): bool\n    {\n        return $user->ownsTeam($team);\n    }\n}"
}
,
{
  "name": "TeamWalletPolicy",
  "code": "<?php\n\nnamespace App\\Policies;\n\nuse App\\Models\\User;\nuse App\\Models\\TeamWallet as Wallet;\nuse Illuminate\\Auth\\Access\\Response;\n\nclass TeamWalletPolicy\n{\n    /**\n     * Determine whether the user can view any models.\n     */\n    public function viewAny(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can view the model.\n     */\n    public function view(User $user, Wallet $wallet): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can create models.\n     */\n    public function create(User $user): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can update the model.\n     */\n    public function update(User $user, Wallet $wallet)\n    {\n        return $user->id === $wallet->user_id;\n    }\n    /**\n     * Determine whether the user can delete the model.\n     */\n    public function delete(User $user, Wallet $wallet): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can restore the model.\n     */\n    public function restore(User $user, Wallet $wallet): bool\n    {\n        return false;\n    }\n\n    /**\n     * Determine whether the user can permanently delete the model.\n     */\n    public function forceDelete(User $user, Wallet $wallet): bool\n    {\n        return false;\n    }\n}"
}
,
{
  "name": "AppServiceProvider",
  "code": "<?php\n\nnamespace App\\Providers;\n\n\nuse App\\Repositories\\IconRepository;\nuse App\\Services\\FileStorageService;\nuse Illuminate\\Support\\ServiceProvider;\n\n\nuse App\\Models\\User;\nuse App\\Models\\TeamWallet as Wallet;\nuse App\\Models\\Collection;\nuse App\\Models\\Egi;\nuse App\\Policies\\ProfilePolicy;\nuse App\\Policies\\TeamWalletPolicy as WalletPolicy;\nuse App\\Policies\\CollectionPolicy;\nuse App\\Policies\\EgiPolicy;\n\nclass AppServiceProvider extends ServiceProvider\n{\n\n    protected $policies = [\n        User::class => ProfilePolicy::class,\n        Wallet::class => WalletPolicy::class,\n        Collection::class => CollectionPolicy::class,\n        // Egi::class => EgiPolicy::class,\n    ];\n\n    /**\n     * Register any application services.\n     */\n    public function register(): void\n    {\n        $this->app->singleton(IconRepository::class);\n\n        // Registra il servizio di storage dei file\n        $this->app->singleton(FileStorageService::class, function () {\n            return new FileStorageService();\n        });\n    }\n\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        //\n    }\n}"
}
,
{
  "name": "FileHelperServiceProvider",
  "code": "<?php\n\n\nnamespace App\\Providers;\n\nuse App\\Helpers\\FileHelper;\nuse Illuminate\\Support\\ServiceProvider;\n\nclass FileHelperServiceProvider extends ServiceProvider\n{\n    public function register()\n    {\n        $this->app->singleton('file-helper', function () {\n            return new FileHelper();\n        });\n    }\n}"
}
,
{
  "name": "FortifyServiceProvider",
  "code": "<?php\n\nnamespace App\\Providers;\n\nuse App\\Actions\\Fortify\\CreateNewUser;\nuse App\\Actions\\Fortify\\ResetUserPassword;\nuse App\\Actions\\Fortify\\UpdateUserPassword;\nuse App\\Actions\\Fortify\\UpdateUserProfileInformation;\nuse Illuminate\\Cache\\RateLimiting\\Limit;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\RateLimiter;\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Support\\Str;\nuse Laravel\\Fortify\\Fortify;\n\nclass FortifyServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     */\n    public function register(): void\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        Fortify::createUsersUsing(CreateNewUser::class);\n        Fortify::updateUserProfileInformationUsing(UpdateUserProfileInformation::class);\n        Fortify::updateUserPasswordsUsing(UpdateUserPassword::class);\n        Fortify::resetUserPasswordsUsing(ResetUserPassword::class);\n\n        RateLimiter::for('login', function (Request $request) {\n            $throttleKey = Str::transliterate(Str::lower($request->input(Fortify::username())).'|'.$request->ip());\n\n            return Limit::perMinute(5)->by($throttleKey);\n        });\n\n        RateLimiter::for('two-factor', function (Request $request) {\n            return Limit::perMinute(5)->by($request->session()->get('login.id'));\n        });\n    }\n}"
}
,
{
  "name": "JetstreamServiceProvider",
  "code": "<?php\n\nnamespace App\\Providers;\n\nuse App\\Actions\\Jetstream\\AddTeamMember;\nuse App\\Actions\\Jetstream\\CreateTeam;\nuse App\\Actions\\Jetstream\\DeleteTeam;\nuse App\\Actions\\Jetstream\\DeleteUser;\nuse App\\Actions\\Jetstream\\InviteTeamMember;\nuse App\\Actions\\Jetstream\\RemoveTeamMember;\nuse App\\Actions\\Jetstream\\UpdateTeamName;\nuse Illuminate\\Support\\ServiceProvider;\nuse Laravel\\Jetstream\\Jetstream;\n\nclass JetstreamServiceProvider extends ServiceProvider\n{\n    /**\n     * Register any application services.\n     */\n    public function register(): void\n    {\n        //\n    }\n\n    /**\n     * Bootstrap any application services.\n     */\n    public function boot(): void\n    {\n        $this->configurePermissions();\n\n        Jetstream::createTeamsUsing(CreateTeam::class);\n        Jetstream::updateTeamNamesUsing(UpdateTeamName::class);\n        Jetstream::addTeamMembersUsing(AddTeamMember::class);\n        Jetstream::inviteTeamMembersUsing(InviteTeamMember::class);\n        Jetstream::removeTeamMembersUsing(RemoveTeamMember::class);\n        Jetstream::deleteTeamsUsing(DeleteTeam::class);\n        Jetstream::deleteUsersUsing(DeleteUser::class);\n    }\n\n    /**\n     * Configure the roles and permissions that are available within the application.\n     */\n    protected function configurePermissions(): void\n    {\n        Jetstream::defaultApiTokenPermissions(['read']);\n\n        Jetstream::role('admin', 'Administrator', [\n            'create',\n            'read',\n            'update',\n            'delete',\n        ])->description('Administrator users can perform any action.');\n\n        Jetstream::role('superadmin', 'SuperAdmin', [\n            'read-config',\n            'create-config',\n            'update-config',\n            'delete-config',\n        ])->description('Ruolo amministrativo con accesso completo alle configurazioni.');\n\n        Jetstream::role('editor', 'Editor', [\n            'read',\n            'create',\n            'update',\n        ])->description('Editor users have the ability to read, create, and update.');\n    }\n}"
}
,
{
  "name": "ViewDebugServiceProvider",
  "code": "<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Support\\ServiceProvider;\nuse Illuminate\\Support\\Facades\\View;\n\nclass ViewDebugServiceProvider extends ServiceProvider\n{\n    public function boot()\n    {\n        View::composer('*', function ($view) {\n            $relativePath = str_replace(\n                base_path('resources/views/') . '/',\n                '',\n                $view->getPath()\n            );\n\n            view()->share('__current_view_path', $relativePath);\n\n            if (app()->environment('local')) {\n                logger()->info('Current view: ' . $relativePath);\n            }\n        });\n    }\n}"
}
,
{
  "name": "IconRepository",
  "code": "<?php\n\nnamespace App\\Repositories;\n\nuse App\\Models\\Icon;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass IconRepository\n{\n    /**\n     * Recupera un'icona specifica dal database o dalla cache.\n     *\n     * @param string $name  Nome dell'icona.\n     * @param string $style Stile dell'icona.\n     * @param string|null $customClass Classe personalizzata (opzionale).\n     * @return string|null  Contenuto HTML dell'icona.\n     */\n    public function getIcon(string $name, string $style, ?string $customClass = null): ?string\n    {\n\n        $this->clearCache($name, $style, $customClass);\n\n        // Log::channel('florenceegi')->info( 'Class IconRepository. Method: getIcon. Action: customClass: (' . $customClass .  ') name: (' . $name .')');\n\n        // Costruisce la chiave della cache\n        $cacheKey = $this->buildCacheKey($name, $style, $customClass);\n        // Log::channel('florenceegi')->info('Cache Key Generated', ['key' => $cacheKey, 'name' => $name, 'style' => $style, 'customClass' => $customClass]);\n\n        // Controlla se l'elemento è già in cache\n        $cachedValue = Cache::get($cacheKey);\n        if ($cachedValue) {\n            // Log::channel('florenceegi')->info('Cache Hit', ['key' => $cacheKey, 'cachedValue' => $cachedValue]);\n\n            // Sostituisce il segnaposto %class% con la classe personalizzata o quella di default\n            $finalClass = $customClass ?? 'default-class';\n            $processedValue = str_replace('%class%', $finalClass, $cachedValue);\n            // Log::channel('florenceegi')->info('Processed Cached Value', ['processedValue' => $processedValue, 'finalClass' => $finalClass]);\n\n            return $processedValue;\n        }\n\n        // Cache miss: esegue la closure per calcolare il valore\n        // Log::channel('florenceegi')->info('Class IconRepository. Method: getIcon. Action: Icon name', ['name' => $name]);\n\n        return Cache::remember($cacheKey, 3600, function () use ($name, $style, $customClass) {\n            // Log::channel('florenceegi')->info('Querying Database', ['name' => $name, 'style' => $style]);\n\n            $query_icon = Icon::where('name', $name)->where('style', $style)->first();\n\n            if (!$query_icon) {\n                Log::channel('florenceegi')->warning('Class IconRepository. Method: getIcon. Action: Icon Not Found', ['name' => $name, 'style' => $style]);\n\n                $fallback_icon = Icon::where('name', 'fallback')->where('style', $style)->first();\n\n                if ($fallback_icon) {\n                    return $fallback_icon->html;\n                }\n\n                return 'fallback'; // Puoi specificare un'icona di fallback\n            }\n\n            if ($customClass) {\n                $finalClass = $customClass;\n            } else {\n                $finalClass = $query_icon->class;\n            }\n\n            // Log::channel('florenceegi')->info('Class IconRepository. Method: getIcon. Action: Processed', ['$finalClass' => $finalClass]);\n            $processedHtml = str_replace('%class%', $finalClass, $query_icon->html);\n\n            return $processedHtml;\n        });\n    }\n\n    /**\n     * Recupera un'icona con lo stile predefinito.\n     *\n     * @param string $name Nome dell'icona.\n     * @return string      Contenuto HTML dell'icona (o fallback).\n     */\n    public function getDefaultIcon(string $name): string\n    {\n        $defaultStyle = config('icons.default');\n\n        // Determina lo stile dell'utente autenticato\n        if (Auth::check()) {\n            $defaultStyle = Auth::user()->icon_style ?? $defaultStyle;\n        }\n\n        return $this->getIcon($name, $defaultStyle) ?? $this->getFallbackIcon();\n    }\n\n\n    /**\n     * Recupera un'icona di fallback se quella richiesta non esiste.\n     *\n     * @return string Contenuto HTML dell'icona di fallback.\n     */\n    protected function getFallbackIcon(): string\n    {\n        return '<svg xmlns=\"http://www.w3.org/2000/svg\" class=\"w-6 h-6 text-gray-400\" fill=\"none\" viewBox=\"0 0 24 24\" stroke=\"currentColor\">\n                    <path stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" d=\"M9 12h6m2 0a2 2 0 00-2-2H9a2 2 0 00-2 2m8 0a2 2 0 01-2 2H9a2 2 0 01-2-2m6 0H9\"></path>\n                </svg>';\n    }\n\n    /**\n     * Rimuove un'icona dalla cache.\n     *\n     * @param string|null $name  Nome dell'icona (opzionale).\n     * @param string|null $style Stile dell'icona (opzionale).\n     */\n    public function clearCache(?string $name = null, ?string $style = null, ?string $customClass): void\n    {\n        if ($name && $style) {\n            $cacheKey = $this->buildCacheKey($name, $style, $customClass);\n            Cache::forget($cacheKey);\n        } else {\n            // Elimina tutte le icone dalla cache\n            Cache::tags(['icons'])->flush();\n        }\n    }\n\n    /**\n     * Precarica tutte le icone in cache.\n     */\n    public function preloadIcons(): void\n    {\n        Icon::all()->each(function ($icon) {\n            $cacheKey = $this->buildCacheKey($icon->name, $icon->style, $icon->customClass);\n            Cache::put($cacheKey, $icon->html, 3600);\n        });\n    }\n\n    /**\n     * Costruisce la chiave della cache per un'icona.\n     *\n     * @param string $name  Nome dell'icona.\n     * @param string $style Stile dell'icona.\n     * @return string Chiave della cache.\n     */\n    protected function buildCacheKey(string $name, string $style, ?string $customClass = null): string\n    {\n        // Usa un hash per evitare che la chiave sia troppo lunga\n        $rawKey = \"icon:{$style}:{$name}:{$customClass}\";\n        return 'icon:' . md5($rawKey);\n    }\n\n}"
}
,
{
  "name": "ValidAlgorandAddress",
  "code": "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\n\nclass ValidAlgorandAddress implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        // Verifica se l'indirizzo è un address Algorand valido\n        return preg_match('/^[A-Z2-7]{58}$/', $value);\n    }\n\n    public function message()\n    {\n        return 'Il valore fornito non è un address Algorand valido.';\n    }\n}"
}
,
{
  "name": "ValidPolygonAddress",
  "code": "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\n\nclass ValidPolygonAddress implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        // Verifica se l'indirizzo è un address Polygon valido\n        return preg_match('/^0x[a-fA-F0-9]{40}$/', $value);\n    }\n\n    public function message()\n    {\n        return 'Il valore fornito non è un address Polygon valido.';\n    }\n}"
}
,
{
  "name": "ValidWalletAddress",
  "code": "<?php\n\nnamespace App\\Rules;\n\nuse Illuminate\\Contracts\\Validation\\Rule;\n\nclass ValidWalletAddress implements Rule\n{\n    public function passes($attribute, $value)\n    {\n        // Regola per Algorand\n        $isAlgorand = preg_match('/^[A-Z2-7]{58}$/', $value);\n\n        // Regola per Polygon\n        $isPolygon = preg_match('/^0x[a-fA-F0-9]{40}$/', $value);\n\n        return $isAlgorand || $isPolygon; // Accetta se è valido per almeno una blockchain\n    }\n\n    public function message()\n    {\n        return 'Il valore fornito non è un address valido per Algorand o Polygon.';\n    }\n}"
}
,
{
  "name": "EGIImageService",
  "code": "<?php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Illuminate\\Support\\Str;\n\nclass EGIImageService\n{\n    /**\n     * Elimina tutti i file che iniziano con $prefix in $pathKey, su tutti i servizi attivi.\n     */\n    public static function removeOldImage(string $prefix, int $collectionId, string $pathKey): bool\n    {\n        $activeHostings = static::getActiveHostings();\n        $folderPath = static::resolveFolderPath($pathKey, $collectionId);\n\n        foreach ($activeHostings as $hostingName => $hostingConfig) {\n            try {\n                $disk = Storage::disk($hostingConfig['disk']);\n                $files = $disk->files($folderPath);\n\n                foreach ($files as $file) {\n                    // Str::startsWith serve a controllare se il filename inizia col prefisso\n                    if (Str::startsWith(basename($file), $prefix)) {\n                        $disk->delete($file);\n                    }\n                }\n            } catch (\\Exception $e) {\n                Log::channel('florenceegi')->error('Errore durante la rimozione del vecchio file', [\n                    'error'        => $e->getMessage(),\n                    'prefix'       => $prefix,\n                    'collectionId' => $collectionId,\n                    'pathKey'      => $pathKey,\n                ]);\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * Salva il file $filename sul disco di tutti i servizi attivi.\n     * Ritorna true se almeno un caricamento va a buon fine.\n     */\n    public static function saveEGIImage(\n        int $collectionId,\n        string $filename,\n        $file,\n        string $pathKey\n    ): bool {\n        $activeHostings = static::getActiveHostings();\n        $folderPath = static::resolveFolderPath($pathKey, $collectionId);\n\n        $atLeastOneSuccess = false;\n\n        foreach ($activeHostings as $hostingName => $hostingConfig) {\n            try {\n                $disk = Storage::disk($hostingConfig['disk']);\n                // Invece di costruire manualmente il filePath e fare file_get_contents,\n                // usiamo putFileAs(), che si occupa di caricare il file correttamente.\n                $disk->putFileAs($folderPath, $file, $filename);\n\n                $atLeastOneSuccess = true;\n            } catch (\\Exception $e) {\n                Log::channel('florenceegi')->error('Errore salvataggio immagine EGI', [\n                    'error'        => $e->getMessage(),\n                    'filename'     => $filename,\n                    'collectionId' => $collectionId,\n                    'hosting'      => $hostingName,\n                ]);\n            }\n        }\n\n        return $atLeastOneSuccess;\n    }\n\n\n    /**\n     * Ritorna l'URL (o percorso) dal caching; se non presente in cache, lo costruisce e lo salva.\n     */\n    public static function getCachedEGIImagePath(\n        int $collectionId,\n        string $filename,\n        bool $isPublished,\n        ?string $hostingService = null,\n        string $pathKey = 'head.banner'\n    ): ?string {\n        if (!$filename) {\n            return null;\n        }\n\n        // Creiamo una chiave univoca per la cache\n        $cacheKey = \"EGIImagePath_{$collectionId}_{$filename}_{$hostingService}\";\n\n        return Cache::remember($cacheKey, now()->addDay(), function () use (\n            $collectionId, $filename, $pathKey, $hostingService, $isPublished\n        ) {\n            // Se non c'è hostingService, usa quello predefinito\n            $hostingToUse = $hostingService ?: static::getDefaultHosting();\n\n            // Ottieni i dettagli dell'hosting\n            $hostingConfig = config(\"paths.hosting.$hostingToUse\");\n            if (!$hostingConfig) {\n                return null;\n            }\n\n            $folderPath = static::resolveFolderPath($pathKey, $collectionId);\n\n            $baseUrl = rtrim($hostingConfig['url'], '/');\n            $fullUrl = \"{$baseUrl}/{$folderPath}{$filename}\";\n\n            // Se l'EGI non è pubblicato, potresti gestire un placeholder o simile\n            if (!$isPublished) {\n                // Esempio, potresti loggare o ritornare un'immagine placeholder\n            }\n\n            return $fullUrl;\n        });\n    }\n\n    /**\n     * Invalida la cache per un certo file.\n     */\n    public static function invalidateEGIImageCache(\n        int $collectionId,\n        string $filename,\n        ?string $hostingService = null\n    ): void {\n        $cacheKey = \"EGIImagePath_{$collectionId}_{$filename}_{$hostingService}\";\n        Cache::forget($cacheKey);\n    }\n\n\n    /**\n     * Recupera i soli hosting con 'is_active' => true\n     */\n    protected static function getActiveHostings(): array\n    {\n        $allHostings = config('paths.hosting', []);\n        return array_filter($allHostings, fn($hosting) => $hosting['is_active'] === true);\n    }\n\n    /**\n     * Restituisce il nome dell'hosting di default (es. \"Local\") o \"Digital Ocean\".\n     */\n    protected static function getDefaultHosting(): string\n    {\n        $default = config('paths.default_hosting', 'Local');\n        return $default;\n    }\n\n    /**\n     * Risolve la path prendendola da config('paths.paths') e sostituendo {collectionId}.\n     */\n    protected static function resolveFolderPath(string $pathKey, int $collectionId): string\n    {\n        $keys = explode('.', $pathKey);\n        $pathsConfig = config('paths.paths', []);\n\n        $current = $pathsConfig;\n        foreach ($keys as $key) {\n            if (!isset($current[$key])) {\n                return '';\n            }\n            $current = $current[$key];\n        }\n\n        // Ora $current è una stringa che contiene \"{collectionId}\"\n        return str_replace('{collectionId}', $collectionId, $current);\n    }\n}"
}
,
{
  "name": "FileStorageService",
  "code": "<?php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Log;\nuse Livewire\\WithFileUploads;\nuse Exception;\nuse Illuminate\\Support\\Facades\\Storage;\nuse App\\Models\\Collection;\n\nclass FileStorageService\n{\n    use WithFileUploads; // Necessario per sfruttare le funzionalità di Livewire\n\n    /**\n     * Salva un file Livewire in una posizione specifica e aggiorna il percorso nel database.\n     *\n     * @param \\Livewire\\TemporaryUploadedFile $file\n     * @param mixed $file\n     * @param string $filename\n     * @param string $disk\n     * @param int $collectionId\n     * @param string $imageType\n     * @return string\n     * @throws Exception\n     */\n    public function saveFile($file, string $path, ?string $filename = null, string $disk = 'public', int $collectionId, string $imageType): string\n    {\n        try {\n            // Usa storeAs per salvare il file\n            if ($filename) {\n                $savedPath = $file->storeAs($path, $filename, $disk);\n            } else {\n                $savedPath = $file->store($path, $disk);\n            }\n\n            Log::channel('florenceegi')->info('File salvato:', ['path' => $savedPath]);\n\n            // Verifica se il file esiste usando il disco passato\n            if (!Storage::disk($disk)->exists($savedPath)) {\n                Log::channel('florenceegi')->error('File non trovato dopo storeAs.', ['path' => $savedPath]);\n                throw new Exception('Errore durante il salvataggio del file.');\n            }\n\n            // Aggiorna il percorso nel database\n            $this->updateCollectionImagePath($collectionId, $savedPath, $imageType);\n\n            return $savedPath; // Restituisce il percorso relativo\n        } catch (Exception $e) {\n            Log::channel('florenceegi')->error('Errore nel salvataggio del file:', ['message' => $e->getMessage()]);\n            throw $e;\n        }\n    }\n\n    /**\n     * Aggiorna il percorso dell'immagine nella tabella collections.\n     *\n     * @param int $collectionId\n     * @param string $savedPath\n     * @param string $imageType\n     * @throws Exception\n     */\n    protected function updateCollectionImagePath(int $collectionId, string $savedPath, string $imageType): void\n    {\n        $collection = Collection::findOrFail($collectionId);\n\n        switch ($imageType) {\n            case 'banner':\n                $collection->path_image_banner = $savedPath;\n                break;\n            case 'card':\n                $collection->path_image_card = $savedPath;\n                break;\n            case 'avatar':\n                $collection->path_image_avatar = $savedPath;\n                break;\n            case 'EGI':\n                $collection->path_image_EGI = $savedPath;\n                break;\n            default:\n                throw new Exception(\"Tipo di immagine non supportato: $imageType\");\n        }\n\n        $collection->save();\n\n        Log::channel('florenceegi')->info('Percorso immagine aggiornato nel database.', [\n            'collection_id' => $collectionId,\n            'image_type' => $imageType,\n            'path' => $savedPath,\n        ]);\n    }\n}"
}
,
{
  "name": "ContextMenus",
  "code": "<?php\n\nnamespace App\\Services\\Menu;\n\nuse App\\Services\\Menu\\Items\\PermissionsRolesMenu;\nuse App\\Services\\Menu\\Items\\AssignRolesMenu;\nuse App\\Services\\Menu\\Items\\AssignPermissionsMenu;\nuse App\\Services\\Menu\\Items\\OpenCollectionMenu;\nuse App\\Services\\Menu\\Items\\NewCollectionMenu;\n\nclass ContextMenus\n{\n    public static function getMenusForContext(string $context): array\n    {\n        $menus = [];\n\n        switch ($context) {\n            case 'dashboard':\n                $adminMenu = new MenuGroup('Admin Tools', '<i class=\"fas fa-tools\"></i>', [\n                    new PermissionsRolesMenu(),\n                    new AssignRolesMenu(),\n                    new AssignPermissionsMenu(),\n                ]);\n                $menus[] = $adminMenu;\n\n                $collectionsMenu = new MenuGroup('Collections', '<i class=\"fas fa-folder-open\"></i>', [\n                    new OpenCollectionMenu(),\n                    new NewCollectionMenu(),\n                ]);\n                $menus[] = $collectionsMenu;\n\n                break;\n\n            case 'collections':\n                $collectionsMenu = new MenuGroup('Collections', '<i class=\"fas fa-folder-open\"></i>', [\n                    new OpenCollectionMenu(),\n                    new NewCollectionMenu(),\n                ]);\n                $menus[] = $collectionsMenu;\n                break;\n\n            default:\n                $defaultMenu = new MenuGroup('General', '<i class=\"fas fa-cogs\"></i>', []);\n                $menus[] = $defaultMenu;\n                break;\n        }\n\n        return $menus;\n    }\n}"
}
,
{
  "name": "AssignPermissionsMenu",
  "code": "<?php\n\nnamespace App\\Services\\Menu\\Items;\n\nuse App\\Services\\Menu\\MenuItem;\n\nclass AssignPermissionsMenu extends MenuItem\n{\n    public function __construct()\n    {\n        parent::__construct('Assign Permissions', 'admin.assign.permissions.form', 'assign_permissions', 'manage_roles');\n    }\n}"
}
,
{
  "name": "AssignRolesMenu",
  "code": "<?php\n\nnamespace App\\Services\\Menu\\Items;\n\nuse App\\Services\\Menu\\MenuItem;\n\nclass AssignRolesMenu extends MenuItem\n{\n    public function __construct()\n    {\n        parent::__construct('Assign Roles', 'admin.assign.role.form', 'assign_roles', 'manage_roles');\n    }\n}"
}
,
{
  "name": "BackToDashboardMenu",
  "code": "<?php\n\nnamespace App\\Services\\Menu\\Items;\n\nuse App\\Services\\Menu\\MenuItem;\n\nclass BackToDashboardMenu extends MenuItem\n{\n    public function __construct()\n    {\n        parent::__construct('Back to Dashboard', 'dashboard', 'back', 'view_dashboard');\n    }\n}"
}
,
{
  "name": "NewCollectionMenu",
  "code": "<?php\n\nnamespace App\\Services\\Menu\\Items;\n\nuse App\\Services\\Menu\\MenuItem;\n\nclass NewCollectionMenu extends MenuItem\n{\n    public function __construct()\n    {\n        parent::__construct('New Collection', 'collections.create', 'new_collection', 'create_collection');\n    }\n}"
}
,
{
  "name": "OpenCollectionMenu",
  "code": "<?php\n\nnamespace App\\Services\\Menu\\Items;\n\nuse App\\Services\\Menu\\MenuItem;\n\nclass OpenCollectionMenu extends MenuItem\n{\n    public function __construct()\n    {\n        parent::__construct('Open Collection', 'collections.open', 'open', 'view_collection');\n    }\n}"
}
,
{
  "name": "PermissionsRolesMenu",
  "code": "<?php\n\nnamespace App\\Services\\Menu\\Items;\n\nuse App\\Services\\Menu\\MenuItem;\n\nclass PermissionsRolesMenu extends MenuItem\n{\n    public function __construct()\n    {\n        parent::__construct('Permissions & Roles', 'admin.roles.index', 'permissions_roles', 'manage_roles');\n    }\n}"
}
,
{
  "name": "MenuConditionEvaluator",
  "code": "<?php\n\nnamespace App\\Services\\Menu;\n\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass MenuConditionEvaluator\n{\n    /**\n     * Verifica se una voce di menu può essere visualizzata in base ai permessi dell'utente.\n     *\n     * @param MenuItem $menuItem\n     * @return bool\n     */\n    public function shouldDisplay(MenuItem $menuItem): bool\n    {\n\n        // dump([\n        //     'item' => $menuItem->name,\n        //     'permission' => $menuItem->permission,\n        //     'user' => Auth::check() ? Auth::user()->toArray() : null,\n        //     'can' => Auth::check() && Auth::user()->can($menuItem->permission),\n        // ]);\n\n        // Se non è richiesto un permesso specifico, mostra la voce di menu\n        if (empty($menuItem->permission)) {\n            return true;\n        }\n\n        // Controlla se l'utente autenticato ha il permesso richiesto\n        return Auth::check() && Auth::user()->can($menuItem->permission);\n    }\n}"
}
,
{
  "name": "MenuGroup",
  "code": "<?php\n\nnamespace App\\Services\\Menu;\n\nclass MenuGroup\n{\n    public string $name;\n    public ?string $icon;\n    public array $items;\n\n    public function __construct(string $name, ?string $icon = null, array $items = [])\n    {\n        $this->name = $name;\n        $this->icon = $icon;\n        $this->items = $items;\n    }\n\n    /**\n     * Aggiunge un item al menu.\n     *\n     * @param MenuItem $item\n     */\n    public function addItem(MenuItem $item): void\n    {\n        $this->items[] = $item;\n    }\n\n    /**\n     * Verifica se il menu ha item visibili.\n     *\n     * @return bool\n     */\n    public function hasVisibleItems(): bool\n    {\n        return !empty($this->items);\n    }\n}"
}
,
{
  "name": "MenuItem",
  "code": "<?php\n\nnamespace App\\Services\\Menu;\n\nclass MenuItem\n{\n    public string $name;\n    public string $route;\n    public ?string $icon;\n    public ?string $permission;\n    /** @var MenuItem[]|null */\n    public ?array $children;\n\n    public function __construct(\n        string $name,\n        string $route,\n        ?string $icon = null,\n        ?string $permission = null,\n        ?array $children = null\n    ) {\n        $this->name = $name;\n        $this->route = $route;\n        $this->icon = $icon;\n        $this->permission = $permission;\n        $this->children = $children;\n    }\n\n    public function hasChildren(): bool\n    {\n        return !empty($this->children);\n    }\n}"
}
,
{
  "name": "MenuScanner",
  "code": "<?php\n\nnamespace App\\Services\\Menu;\n\nuse Illuminate\\Support\\Facades\\File;\n\nclass MenuScanner\n{\n    protected string $itemsPath = 'app/Services/Menu/Items';\n\n    /**\n     * @return array<string, MenuItem[]>\n     *\n     * Restituisce un array associativo con chiave = contesto, valore = array di MenuItem\n     */\n    public function getMenuGroups(): array\n    {\n        // Supponiamo che le classi menu abbiano dei naming convention tipo: Admin*, Dashboard*, Collections*, ...\n        // O che magari tu abbia un metodo più intelligente per capire il contesto.\n        // Qui ipotizziamo di fare i raggruppamenti in base alle route: per esempio route 'admin.xxx' => 'admin'\n\n        // Per semplicità, immaginiamo che il metodo seguente esista o lo implementi tu:\n        // loadAllMenuItems(): ritorna un array di istanze MenuItem caricate dinamicamente\n        $allItems = $this->loadAllMenuItems();\n\n        $groups = [];\n        foreach ($allItems as $item) {\n            // Estraiamo il contesto dalla route\n            $context = explode('.', $item->route)[0] ?? 'dashboard';\n            $groups[$context][] = $item;\n        }\n\n        return $groups;\n    }\n\n    protected function loadAllMenuItems(): array\n    {\n        $items = [];\n        // Carica tutte le classi in app/Services/Menu/Items\n        $files = File::files(base_path($this->itemsPath));\n        foreach ($files as $file) {\n            $className = 'App\\\\Services\\\\Menu\\\\Items\\\\' . $file->getFilenameWithoutExtension();\n            if (class_exists($className)) {\n                $instance = new $className();\n                if ($instance instanceof MenuItem) {\n                    $items[] = $instance;\n                }\n            }\n        }\n        return $items;\n    }\n}"
}
,
{
  "name": "InvitationNotificationHandler",
  "code": "<?php\n\n\nnamespace App\\Services\\Notifications;\n\nuse App\\Contracts\\NotificationHandlerInterface;\nuse Illuminate\\Notifications\\DatabaseNotification;\nuse App\\Models\\CollectionInvitation;\nuse App\\Models\\CollectionUser;\nuse Illuminate\\Support\\Facades\\Auth;\n\nclass InvitationNotificationHandler implements NotificationHandlerInterface\n{\n    public function handle(DatabaseNotification $notification, string $action)\n    {\n        $invitationId = $notification->data['invitation_id'];\n\n        if ($action === 'accept') {\n            $invitation = CollectionInvitation::findOrFail($invitationId);\n            $invitation->update(['status' => 'accepted']);\n\n            CollectionUser::create([\n                'collection_id' => $invitation->collection_id,\n                'user_id' => Auth::id(),\n                'role' => $invitation->role,\n            ]);\n\n            $notification->update(['outcome' => 'accepted']);\n        } elseif ($action === 'decline') {\n            $invitation = CollectionInvitation::findOrFail($invitationId);\n            $invitation->update(['status' => 'declined']);\n\n            $notification->update(['outcome' => 'declined']);\n        } else {\n            throw new \\Exception(\"Azione '{$action}' non supportata per InvitationNotification.\");\n        }\n    }\n}"
}
,
{
  "name": "NotificationHandlerFactory",
  "code": "<?php\n\nnamespace App\\Services\\Notifications;\n\nuse App\\Contracts\\NotificationHandlerInterface;\n\nclass NotificationHandlerFactory\n{\n    public static function getHandler(string $type): NotificationHandlerInterface\n    {\n        $handlers = [\n            'App\\Notifications\\WalletChangeRequest' => WalletChangeRequestHandler::class,\n            'App\\Notifications\\InvitationNotification' => InvitationNotificationHandler::class,\n        ];\n\n        if (!isset($handlers[$type])) {\n            throw new \\Exception(\"Gestore per il tipo '{$type}' non trovato.\");\n        }\n\n        return app($handlers[$type]);\n    }\n}"
}
,
{
  "name": "WalletChangeRequestHandler",
  "code": "<?php\n\nnamespace App\\Services\\Notifications;\n\nuse App\\Contracts\\NotificationHandlerInterface;\nuse App\\Models\\WalletChangeApproval;\nuse Illuminate\\Support\\Facades\\Notification;\nuse App\\Notifications\\WalletChangeRequest;\n\nclass WalletChangeRequestHandler implements NotificationHandlerInterface\n{\n    public function handle($data, string $action)\n    {\n        if ($action === 'proposal') {\n            // Invio della notifica iniziale\n            $approval = $data; // Il modello WalletChangeApproval\n            $receiver = $approval->approver; // Utente destinatario (approver) definito nella relazione in WalletChangeApproval\n            Notification::send($receiver, new WalletChangeRequest($approval));\n        } elseif ($action === 'accept') {\n            // Logica per accettare\n            WalletChangeApproval::findOrFail($data['approval_id'])->update(['status' => 'approved']);\n        } elseif ($action === 'decline') {\n            // Logica per declinare\n            WalletChangeApproval::findOrFail($data['approval_id'])->update(['status' => 'declined']);\n        } else {\n            throw new \\Exception(\"Azione '{$action}' non supportata per WalletChangeRequest.\");\n        }\n    }\n}\n    "
}
,
{
  "name": "WalletProposalHandler",
  "code": "<?php\n\nnamespace App\\Services\\Proposals\\Handlers;\n\nuse App\\Contracts\\ProposalHandlerInterface;\nuse App\\Models\\WalletChangeApproval;\nuse App\\Notifications\\ProposalDeclinedNotification;\nuse Exception;\n\nclass WalletProposalHandler implements ProposalHandlerInterface\n{\n    /**\n     * Gestisce il declino di una proposta di modifica del wallet.\n     *\n     * @param int $proposalId\n     * @param string $reason\n     * @return void\n     * @throws Exception\n     */\n    public function decline(int $proposalId, string $reason): void\n    {\n        $proposal = WalletChangeApproval::findOrFail($proposalId);\n\n        if ($proposal->status !== 'pending') {\n            throw new Exception(\"The proposal is not in a pending state.\");\n        }\n\n        // Aggiorna lo stato della proposta e aggiunge la motivazione\n        $proposal->update([\n            'status' => 'declined',\n            'rejection_reason' => $reason,\n        ]);\n\n        // Invia una notifica al proponente\n        $proposal->requestedBy->notify(\n            new ProposalDeclinedNotification($proposal, $reason)\n        );\n    }\n}"
}
,
{
  "name": "ProposalHandlerFactory",
  "code": "<?php\n\nnamespace App\\Services\\Proposals;\n\nuse App\\Contracts\\ProposalHandlerInterface;\nuse Exception;\n\nclass ProposalHandlerFactory\n{\n    /**\n     * Restituisce il gestore appropriato in base al contesto.\n     *\n     * @param string $context\n     * @return ProposalHandlerInterface\n     * @throws Exception\n     */\n    public function getHandler(string $context): ProposalHandlerInterface\n    {\n        $handlers = [\n            'wallet' => \\App\\Services\\Proposals\\Handlers\\WalletProposalHandler::class,\n            'invitation' => \\App\\Services\\Proposals\\Handlers\\InvitationProposalHandler::class,\n            // Aggiungere altri handler qui\n        ];\n\n        if (!isset($handlers[$context])) {\n            throw new Exception(\"Handler for context '{$context}' not found.\");\n        }\n\n        return app($handlers[$context]);\n    }\n}"
}
,
{
  "name": "HasCreateDefaultCollectionWallets",
  "code": "<?php\n\nnamespace App\\Traits;\n\nuse App\\Models\\Collection;\nuse App\\Models\\Wallet;\nuse Illuminate\\Support\\Facades\\DB;\n\ntrait HasCreateDefaultCollectionWallets\n{\n    /**\n     * Genera i wallet di default per una collection.\n     *\n     * @param  Collection  $collection\n     * @param  string  $wallet_creator\n     */\n    public function generateDefaultWallets(Collection $collection, string $wallet_creator, $creator_id): void\n    {\n        $natan_wallet_address = config('app.natan_wallet_address');\n        $natan_royalty_mint = config('app.natan_royalty_mint');\n        $natan_royalty_rebind = config('app.natan_royalty_rebind');\n        $mediator_royalty_mint = config('app.mediator_royalty_mint');\n        $mediator_royalty_rebind = config('app.mediator_royalty_rebind');\n        $epp_wallet_address = config('app.epp_wallet_address');\n        $epp_royalty_mint = config('app.epp_royalty_mint');\n        $epp_royalty_rebind = config('app.epp_royalty_rebind');\n        $creator_royalty_mint = config('app.creator_royalty_mint');\n        $creator_royalty_rebind = config('app.creator_royalty_rebind');\n        $natan_id = config('app.natan_id');\n        $epp_id = config('app.epp_id');\n\n        DB::transaction(function () use (\n            $collection,\n            $natan_wallet_address,\n            $natan_royalty_mint,\n            $natan_royalty_rebind,\n            $mediator_royalty_mint,\n            $mediator_royalty_rebind,\n            $epp_wallet_address,\n            $epp_royalty_mint,\n            $epp_royalty_rebind,\n            $wallet_creator,\n            $creator_royalty_mint,\n            $creator_royalty_rebind,\n            $natan_id,\n            $epp_id,\n            $creator_id\n        ) {\n            // Wallet per natan\n            $this->createWallet('natan', $natan_wallet_address, $natan_royalty_mint, $natan_royalty_rebind, $collection, $natan_id);\n\n            // Wallet per il Mediator (di default uguale a natan)\n            // PER IL MOMENTO NON GESTITO\n            // $this->createWallet('Mediator', $natan_wallet_address, $mediator_royalty_mint, $mediator_royalty_rebind, $collection);\n\n            // Wallet per EPP\n            $this->createWallet('EPP', $epp_wallet_address, $epp_royalty_mint, $epp_royalty_rebind, $collection, $epp_id);\n\n            // Wallet per il Creator\n            $this->createWallet('Creator', $wallet_creator, $creator_royalty_mint, $creator_royalty_rebind, $collection, $creator_id);\n        });\n    }\n\n    /**\n     * Crea un wallet per una collection.\n     *\n     * @param  string  $role\n     * @param  string  $address\n     * @param  string  $royalty_mint\n     * @param  string  $royalty_rebind\n     * @param  Collection  $collection\n     */\n    protected function createWallet(string $role, string $address, string $royalty_mint, string $royalty_rebind, Collection $collection, $id): void\n    {\n        Wallet::create([\n            'collection_id' => $collection->id,\n            'user_id' => $id,\n            'platform_role' => $role,\n            'wallet' => $address,\n            'royalty_mint' => $royalty_mint,\n            'royalty_rebind' => $royalty_rebind,\n        ]);\n    }\n}"
}
,
{
  "name": "HasPermissionTrait",
  "code": "<?php\n\nnamespace App\\Traits;\n\nuse App\\Models\\CollectionUser;\nuse Illuminate\\Support\\Facades\\Auth;\nuse Illuminate\\Support\\Facades\\Log;\nuse Spatie\\Permission\\Models\\Role;\n\ntrait HasPermissionTrait\n{\n    /**\n     * Verifica se l'utente autenticato ha il permesso specificato per una collezione.\n     *\n     * @param  $collection\n     * @param  string  $permission\n     * @return bool\n     * @throws \\Illuminate\\Auth\\Access\\AuthorizationException\n     */\n    public function hasPermission($collection, string $permission): bool\n    {\n        // Recupera l'utente autenticato\n        $user = Auth::user();\n\n        Log::channel('florenceegi')->info('HasPermissionTraits: User: ' . $user->id);\n\n        // Leggi il ruolo dell'utente nella tabella collection_user\n        $roleName = $collection->users()\n            ->where('user_id', $user->id)\n            ->pluck('role')\n            ->first();\n\n            Log::channel('florenceegi')->info('HasPermissionTraits: Debug Info', [\n                'User ID' => $user->id,\n                'Collection ID' => $collection->id,\n                'Role Name' => $roleName\n            ]);\n\n        if (!$roleName) {\n            // Lancia un'eccezione se l'utente non è associato alla collezione\n            throw new \\Illuminate\\Auth\\Access\\AuthorizationException('user id: '. $user->name . ' '. $user->last_name.  ' Non sei associato a questa collezione.');\n        }\n\n        // Verifica se il ruolo dell'utente ha il permesso richiesto\n        $hasPermission = Role::where('name', $roleName)\n            ->whereHas('permissions', function ($query) use ($permission) {\n                $query->where('name', $permission);\n            })\n            ->exists();\n\n        if (!$hasPermission) {\n            // Lancia un'eccezione se il permesso non è presente\n            throw new \\Illuminate\\Auth\\Access\\AuthorizationException('Non hai i permessi necessari per eseguire questa azione.');\n        }\n\n        return true;\n    }\n\n    public function userHasPermissionInCollection($collectionId, $permission)\n    {\n        $userId = Auth::id();\n\n        // Recupera il ruolo dell'utente nella collection\n        $role = CollectionUser::where('collection_id', $collectionId)\n            ->where('user_id', $userId)\n            ->pluck('role')\n            ->first();\n\n        // Verifica se il ruolo ha il permesso specifico\n        return Role::where('name', $role)\n            ->whereHas('permissions', function ($query) use ($permission) {\n                $query->where('name', $permission);\n            })\n            ->exists();\n    }\n}"
}
,
{
  "name": "HasTeamRoles",
  "code": "<?php\n\nnamespace App\\Traits;\n\nuse Spatie\\Permission\\Traits\\HasRoles;\n\ntrait HasTeamRoles\n{\n    use HasRoles;\n\n    /**\n     * Assegna un ruolo all'utente in un contesto di team specifico.\n     */\n    public function assignRoleToTeam(string $role, $team)\n    {\n        $this->assignRole($role, $team);\n    }\n\n    /**\n     * Verifica se l'utente ha un ruolo specifico in un team.\n     */\n    public function hasRoleInTeam(string $role, $team): bool\n    {\n        return $this->hasRole($role, $team);\n    }\n\n    /**\n     * Relazione con i ruoli assegnati in un contesto di team.\n     */\n    public function roles()\n    {\n        return $this->morphToMany(\n            config('permission.models.role'),\n            'model',\n            config('permission.table_names.model_has_roles'),\n            'model_id',\n            'role_id'\n        )->withPivot('team_id');\n    }\n}"
}
,
{
  "name": "HasTeams",
  "code": "<?php\n\nnamespace Laravel\\Jetstream;\n\nuse Illuminate\\Support\\Str;\nuse Laravel\\Sanctum\\HasApiTokens;\n\ntrait HasTeams\n{\n    /**\n     * Determine if the given team is the current team.\n     *\n     * @param  mixed  $team\n     * @return bool\n     */\n    public function isCurrentTeam($team)\n    {\n        return $team->id === $this->currentTeam->id;\n    }\n\n    /**\n     * Get the current team of the user's context.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsTo\n     */\n    public function currentTeam()\n    {\n        if (is_null($this->current_team_id) && $this->id) {\n            $this->switchTeam($this->personalTeam());\n        }\n\n        return $this->belongsTo(Jetstream::teamModel(), 'current_team_id');\n    }\n\n    /**\n     * Switch the user's context to the given team.\n     *\n     * @param  mixed  $team\n     * @return bool\n     */\n    public function switchTeam($team)\n    {\n        if (! $this->belongsToTeam($team)) {\n            return false;\n        }\n\n        $this->forceFill([\n            'current_team_id' => $team->id,\n        ])->save();\n\n        $this->setRelation('currentTeam', $team);\n\n        return true;\n    }\n\n    /**\n     * Get all of the teams the user owns or belongs to.\n     *\n     * @return \\Illuminate\\Support\\Collection\n     */\n    public function allTeams()\n    {\n        return $this->ownedTeams->merge($this->teams)->sortBy('name');\n    }\n\n    /**\n     * Get all of the teams the user owns.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\HasMany\n     */\n    public function ownedTeams()\n    {\n        return $this->hasMany(Jetstream::teamModel());\n    }\n\n    /**\n     * Get all of the teams the user belongs to.\n     *\n     * @return \\Illuminate\\Database\\Eloquent\\Relations\\BelongsToMany\n     */\n    public function teams()\n    {\n        return $this->belongsToMany(Jetstream::teamModel(), Jetstream::membershipModel())\n                        ->withPivot('role')\n                        ->withTimestamps()\n                        ->as('membership');\n    }\n\n    /**\n     * Get the user's \"personal\" team.\n     *\n     * @return \\App\\Models\\Team\n     */\n    public function personalTeam()\n    {\n        return $this->ownedTeams->where('personal_team', true)->first();\n    }\n\n    /**\n     * Determine if the user owns the given team.\n     *\n     * @param  mixed  $team\n     * @return bool\n     */\n    public function ownsTeam($team)\n    {\n        if (is_null($team)) {\n            return false;\n        }\n\n        return $this->id == $team->{$this->getForeignKey()};\n    }\n\n    /**\n     * Determine if the user belongs to the given team.\n     *\n     * @param  mixed  $team\n     * @return bool\n     */\n    public function belongsToTeam($team)\n    {\n        if (is_null($team)) {\n            return false;\n        }\n\n        return $this->ownsTeam($team) || $this->teams->contains(function ($t) use ($team) {\n            return $t->id === $team->id;\n        });\n    }\n\n    /**\n     * Get the role that the user has on the team.\n     *\n     * @param  mixed  $team\n     * @return \\Laravel\\Jetstream\\Role|null\n     */\n    public function teamRole($team)\n    {\n        if ($this->ownsTeam($team)) {\n            return new OwnerRole;\n        }\n\n        if (! $this->belongsToTeam($team)) {\n            return;\n        }\n\n        $role = $team->users\n            ->where('id', $this->id)\n            ->first()\n            ->membership\n            ->role;\n\n        return $role ? Jetstream::findRole($role) : null;\n    }\n\n    /**\n     * Determine if the user has the given role on the given team.\n     *\n     * @param  mixed  $team\n     * @param  string  $role\n     * @return bool\n     */\n    public function hasTeamRole($team, string $role)\n    {\n        if ($this->ownsTeam($team)) {\n            return true;\n        }\n\n        return $this->belongsToTeam($team) && optional(Jetstream::findRole($team->users->where(\n            'id', $this->id\n        )->first()->membership->role))->key === $role;\n    }\n\n    /**\n     * Get the user's permissions for the given team.\n     *\n     * @param  mixed  $team\n     * @return array\n     */\n    public function teamPermissions($team)\n    {\n        if ($this->ownsTeam($team)) {\n            return ['*'];\n        }\n\n        if (! $this->belongsToTeam($team)) {\n            return [];\n        }\n\n        return (array) optional($this->teamRole($team))->permissions;\n    }\n\n    /**\n     * Determine if the user has the given permission on the given team.\n     *\n     * @param  mixed  $team\n     * @param  string  $permission\n     * @return bool\n     */\n    public function hasTeamPermission($team, string $permission)\n    {\n        if ($this->ownsTeam($team)) {\n            return true;\n        }\n\n        if (! $this->belongsToTeam($team)) {\n            return false;\n        }\n\n        if (in_array(HasApiTokens::class, class_uses_recursive($this)) &&\n            ! $this->tokenCan($permission) &&\n            $this->currentAccessToken() !== null) {\n            return false;\n        }\n\n        $permissions = $this->teamPermissions($team);\n\n        return in_array($permission, $permissions) ||\n               in_array('*', $permissions) ||\n               (Str::endsWith($permission, ':create') && in_array('*:create', $permissions)) ||\n               (Str::endsWith($permission, ':update') && in_array('*:update', $permissions));\n    }\n}"
}
,
{
  "name": "HasUtilitys",
  "code": "<?php\n\nnamespace App\\Traits;\n\nuse App\\Exceptions\\ErrorDispatcher;\nuse App\\Exceptions\\ErrorResult;\nuse App\\Mail\\ErrorOccurredMailable;\nuse App\\Services\\TestingConditionsManager;\nuse Defuse\\Crypto\\Crypto;\nuse Defuse\\Crypto\\Exception\\BadFormatException;\nuse Defuse\\Crypto\\Exception\\EnvironmentIsBrokenException;\nuse Defuse\\Crypto\\Exception\\WrongKeyOrModifiedCiphertextException;\nuse Defuse\\Crypto\\Key;\nuse Exception;\nuse Illuminate\\Support\\Facades\\App;\nuse Illuminate\\Support\\Facades\\Cookie;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Mail;\nuse Illuminate\\Support\\Facades\\Storage;\n\ntrait HasUtilitys\n{\n    /**\n     * Get the disk that profile photos should be stored on.\n     */\n    protected function folderRoot(): string\n    {\n        return isset($_ENV['FOLDER_ROOT']) ? $_ENV['FOLDER_ROOT'] : 'storage';\n    }\n\n    /**\n     * Encrypt and decrypt\n     *\n     * @author Nazmul Ahsan <n.mukto@gmail.com>\n     *\n     * @link http://nazmulahsan.me/simple-two-way-function-encrypt-decrypt-string\n     *\n     * @param  string  $string  string to be encrypted/decrypted\n     * @param  string  $action  what to do with this? e for encrypt, d for decrypt\n     */\n    public function my_simple_crypt($string, $action = 'e'): bool|string\n    {\n        // you may change these values to your own\n        $secret_key = 'my_simple_secret_key';\n        $secret_iv = 'my_simple_secret_iv';\n\n        $output = false;\n        $encrypt_method = 'AES-256-CBC';\n        $key = hash('sha256', $secret_key);\n        $iv = substr(hash('sha256', $secret_iv), 0, 16);\n\n        if ($action == 'e') {\n            $output = base64_encode(openssl_encrypt($string, $encrypt_method, $key, 0, $iv));\n        } elseif ($action == 'd') {\n            $output = openssl_decrypt(base64_decode($string), $encrypt_method, $key, 0, $iv);\n        }\n\n        return $output;\n    }\n\n    /**\n     * Cripta o decripta una stringa utilizzando la chiave di crittografia fornita.\n     *\n     * @param  string  $string  La stringa da criptare o decriptare.\n     * @param  string  $action  L'azione da eseguire: 'e' per criptare, 'd' per decriptare.\n     * @return bool|string Restituisce la stringa criptata/decriptata o false in caso di errore.\n     *\n     * @throws EnvironmentIsBrokenException Se l'ambiente di esecuzione non supporta la crittografia sicura.\n     * @throws BadFormatException Se la chiave fornita ha un formato errato.\n     * @throws WrongKeyOrModifiedCiphertextException Se la chiave fornita non è valida o se la stringa criptata è stata modificata.\n     *\n     * Note: Assicurarsi di non perdere la chiave di crittografia. Senza di essa, non sarà possibile decriptare i dati.\n     */\n    public function my_advanced_crypt($string, $action = 'e'): bool|string\n    {\n\n        if (empty($string) || empty($action) || $string == null || $action == null) {\n            return false;\n        }\n\n        // Utilizza una chiave esistente dalla sua rappresentazione ASCII safe\n        $key_ascii = config('app.data_crypto_key');  // Recupera questa chiave da un posto sicuro (es. .env)\n\n        try {\n\n            $key = Key::loadFromAsciiSafeString($key_ascii);\n\n        } catch (BadFormatException $e) {\n\n            $yourErrorDetails = [\n                'Error' => 'Error n. 0001.',\n                'Trait' => 'HasUtility',\n                'Method' => 'my_advanced_crypt',\n                'Situation' => $e->getMessage(),\n                'SystemError' => $e->getCode(),\n            ];\n\n            Log::channel('upload')->error(json_encode($yourErrorDetails));\n\n            return false;\n        }\n\n        if ($action == 'e') {\n\n            try {\n\n                return Crypto::encrypt($string, $key);\n\n            } catch (EnvironmentIsBrokenException|Exception $e) {\n                // Questa eccezione si verifica se l'ambiente di esecuzione non è sicuro.\n                Log::channel('upload')->error(json_encode([\n                    'message' => $e->getMessage(),\n                    'code' => $e->getCode()\n                ]));\n                return false;\n            }\n\n        } elseif ($action == 'd') {\n\n            try {\n\n                return Crypto::decrypt($string, $key);\n\n            } catch (WrongKeyOrModifiedCiphertextException|EnvironmentIsBrokenException|Exception $e) {\n                Log::channel('upload')->error(json_encode([\n                    'message' => $e->getMessage(),\n                    'code' => $e->getCode()\n                    ]));\n                return false;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Get the disk that profile photos should be stored on.\n     */\n    protected function defProfilePhotoDisk(): string\n    {\n        return isset($_ENV['VAPOR_ARTIFACT_NAME']) ? 's3' : config('jetstream.profile_photo_disk', 'public');\n    }\n\n    public function formatPriceInAlgo(int $amount): string\n    {\n        return number_format($amount, 2, '.', ',').' Algo';\n    }\n\n    /**\n     * Format the size in megabytes.\n     *\n     * @param  int  $sizeInBytes  The size in bytes to be formatted.\n     * @return string The formatted size in megabytes.\n     */\n    public function formatSizeInMegabytes(int $sizeInBytes): string\n    {\n        $megabytes = $sizeInBytes / (1024 * 1024);\n\n        return number_format($megabytes, 2).' MB';\n    }\n\n    /**\n     * Gestisce e aggiorna la lingua dell'utente basata sulla lingua locale.\n     *\n     * 1. Legge la lingua locale.\n     * 2. Aggiorna la lingua nella sessione.\n     * 3. Imposta un cookie per conservare le preferenze di lingua dell'utente per 30 giorni.\n     *\n     * @return string Ritorna la lingua attualmente impostata.\n     */\n    public function languageHandling(): string\n    {\n        // 1. Legge la lingua locale.\n        $language = App::getLocale();\n\n        // 2. Aggiorna la lingua nella sessione.\n        session()->put('locale', $language);\n\n        // 3. Imposta un cookie per conservare le preferenze di lingua dell'utente.\n        // (Nota: è importante gestire il consenso dell'utente per i cookie in conformità con il GDPR)\n        Cookie::queue('language', $language, 60 * 24 * 30); // Il cookie scade dopo 30 giorni.\n\n        return $language;\n    }\n\n    /**\n     * Send an error email.\n     *\n     * @param  array  $yourErrorDetails  Details of the error to be sent.\n     * @param  string|null  $emailAddress  Optional email address to send the error to.\n     * @return bool Returns true if the email is sent successfully and false if not.\n     */\n    public function sendErrorEmail(array $yourErrorDetails, ?string $emailAddress = null): bool\n    {\n        if ($emailAddress === null) {\n            $emailAddress = config('app.errors_email');\n        }\n\n        try {\n            Mail::to($emailAddress)->send(new ErrorOccurredMailable($yourErrorDetails));\n\n            // L'e-mail è stata inviata con successo\n            return true;\n\n        } catch (\\Exception $e) {\n\n            // L'e-mail non è stata inviata\n            $yourErrorDetails = [\n                'error' => 'Error n. 999.',\n                'Trait' => 'HasUtility',\n                'method' => 'sendErrorEmail',  // nome del metodo corretto\n                'situation' => $e->getMessage(),\n            ];\n            Log::channel('nft_transaction')->error(json_encode($yourErrorDetails));\n\n            return false;\n        }\n    }\n\n    private function generateFakeAlgorandAddress(): string\n    {\n        $characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';\n        $address = '';\n        for ($i = 0; $i < 36; $i++) {\n            $address .= $characters[rand(0, strlen($characters) - 1)];\n        }\n\n        return $address;\n    }\n\n    /**\n     * Verifica l'esistenza di una directory e ne garantisce i permessi corretti.\n     *\n     * Questa funzione controlla se la directory specificata esiste; se non esiste, tenta di crearla\n     * con i permessi forniti come argomento. In seguito, controlla i permessi attuali della directory\n     * e, se necessario, li modifica. Se l'operazione fallisce (creazione o modifica dei permessi),\n     * restituisce un codice di errore predefinito.\n     *\n     * @param string $directory           Il percorso della directory da verificare o creare.\n     * @param int $requiredPermissions    I permessi da applicare alla directory (default: 0755).\n     *\n     * @return string                     Restituisce `NOT_ERROR` se la directory esiste o viene creata/modificata con successo,\n     *                                    altrimenti un codice di errore (stringa) definito in 'error_constants'.\n     *\n     * Logica:\n     * - Se la directory non esiste, tenta di crearla.\n     * - Se i permessi della directory non corrispondono a quelli richiesti, tenta di modificarli.\n     * - Se fallisce in una di queste operazioni, registra un errore nei log e restituisce un codice di errore.\n     *\n     * Logging:\n     * - Registra nei log il successo o il fallimento di ogni azione, inclusi classe, metodo e azione specifica\n     *   per un migliore debugging nei sistemi di log centralizzati.\n     *\n     * Esempio d'uso:\n     * $result = ensureDirectoryPermissions('/path/to/directory');\n     * if ($result !== true) {\n     *     // Gestire l'errore basato sul codice restituito\n     * }\n     */\n\n    function ensureDirectoryPermissions($directory, $requiredPermissions = 0755): string {\n\n        $logParams = [\n            'Traits' => 'HasUtility',\n            'Method' => 'ensureDirectoryPermissions',\n        ];\n\n        Log::channel('upload')->info(json_encode($logParams), [\n            'Action' => 'Tentativo di creazione della directory',\n            'directory' => $directory]);\n\n        // Simula un errore durante la creazione della directory\n        if (TestingConditionsManager::getInstance()->isTesting('UNABLE_TO_CREATE_DIRECTORY')) {\n\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Simulazione di errore durante la creazione della directory',\n                'directory' => $directory]);\n\n            return 'UNABLE_TO_CREATE_DIRECTORY';\n        }\n\n        // Verifica se la directory esiste\n        if (!file_exists($directory)) {\n            // La directory non esiste, tenta di crearla\n            try {\n                if (!mkdir($directory, $requiredPermissions, true)) {\n\n                    Log::channel('upload')->error(json_encode($logParams), [\n                        'Action' => 'Impossibile creare la directory',\n                        'directory' => $directory]);\n\n                    return 'UNABLE_TO_CREATE_DIRECTORY';\n\n                }\n            } catch (\\Exception $e) {\n\n                Log::channel('upload')->error(json_encode($logParams), [\n                    'Action' => 'Impossibile creare la directory',\n                    'directory' => $directory]);\n\n                return 'UNABLE_TO_CREATE_DIRECTORY';\n\n            }\n        }\n\n        // Simula un errore durante la modifica dei permessi della directory\n        if (TestingConditionsManager::getInstance()->isTesting('UNABLE_TO_CHANGE_PERMISSIONS')) {\n\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Simulazione di errore durante la modifica dei permessi della directory',\n                'directory' => $directory]);\n\n            return 'UNABLE_TO_CHANGE_PERMISSIONS';\n\n        }\n\n        // Controlla i permessi attuali\n        $currentPermissions = fileperms($directory) & 0777;\n        if ($currentPermissions !== $requiredPermissions) {\n            // I permessi della directory non corrispondono a quelli richiesti, tenta di modificarli\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Modifica dei permessi della directory necessaria',\n                'currentPermissions' => $currentPermissions,\n                'directory' => $directory]);\n\n            try {\n                if (!chmod($directory, $requiredPermissions)) {\n\n                    Log::channel('upload')->error(json_encode($logParams), [\n                        'Action' => ' Impossibile cambiare i permessi della directory',\n                        'currentPermissions' => $currentPermissions,\n                        'directory' => $directory]);\n\n                return 'UNABLE_TO_CHANGE_PERMISSIONS';\n\n                }\n            } catch (\\Exception $e) {\n\n                Log::channel('upload')->error(json_encode($logParams), [\n                    'Action' => 'Errore durante la modifica dei permessi',\n                    'error' => $e->getMessage(),\n                    'directory' => $directory]);\n\n                return 'UNABLE_TO_CHANGE_PERMISSIONS';\n            }\n        }\n\n        Log::channel('upload')->info(json_encode($logParams), [\n            'Action' => 'Directory esistente e permessi corretti',\n            'directory' => $directory,\n            'codeError' => 'NOT_ERROR']);\n\n        return 'NOT_ERROR';\n    }\n\n    /**\n    * Cambia i permessi di un file o di una directory.\n    *\n    * @param string $path\n    * @param string $type ('file' o 'directory')\n    * @return bool True se i permessi sono stati cambiati con successo, False altrimenti\n    */\n    private function changePermissions($path, $type)\n    {\n\n        $logParams = [\n            'Traits' => 'HasUtility',\n            'Method' => 'changePermissions',\n        ];\n\n        try {\n            chmod($path, $type === 'file' ? 0664 : 0775);\n\n            Log::channel('upload')->info(json_encode($logParams), [\n                'Action' => 'Permessi cambiati con successo su ' . $type,\n                'path' => $path]);\n\n            return true;\n\n        } catch (Exception $e) {\n\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Errore cambiando permessi su ' . $type,\n                'error' => $e->getMessage(),\n                'path' => $path]);\n\n            return false;\n\n        }\n    }\n\n    /**\n     * Gestisce l'eliminazione e ricreazione della directory.\n     *\n     * @param string $path\n     * @return void\n     * @throws Exception\n     */\n    private function handleDirectoryError($path):void\n    {\n\n        $logParams = [\n            'Traits' => 'HasUtility',\n            'Method' => 'handleDirectoryError',\n        ];\n\n        try {\n            // Elimina la directory\n            Storage::deleteDirectory($path);\n\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Directory eliminata con successo',\n                'path' => $path]);\n\n            // Ricrea la directory con permessi 0775\n            Storage::makeDirectory($path, 0775, true);\n\n            Log::channel('upload')->info(json_encode($logParams), [\n                'Action' => 'Directory ricreata con successo',\n                'path' => $path]);\n\n            // Prova a cambiare i permessi della nuova directory\n            if (!$this->changePermissions($path, 'directory')) {\n                throw new Exception(\"Impossibile cambiare i permessi della directory dopo la ricreazione: {$path}\");\n            }\n\n        } catch (Exception $e) {\n\n            $errorMessage = $e->getMessage();\n\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Errore durante la cancellazione e ricreazione della directory',\n                'error' => $errorMessage,\n                'path' => $path]);\n\n            throw new Exception($errorMessage);\n        }\n    }\n\n    /**\n     * Crea una directory con permessi specifici.\n     *\n     * @param string $path\n     * @return void\n     * @throws Exception\n     */\n    private function createDirectory($path)\n    {\n\n        $logParams = [\n            'Traits' => 'HasUtility',\n            'Method' => 'createDirectory',\n        ];\n\n        try {\n            // Tentativo di creare la directory con permessi 0775\n            if (!mkdir($path, 0775, true) && !is_dir($path)) {\n                throw new Exception(\"Impossibile creare la directory temporanea: {$path}\");\n            }\n\n            Log::channel('upload')->info(json_encode($logParams), [\n                'Action' => 'Directory creata con successo',\n                'path' => $path]);\n\n\n        } catch (Exception $e) {\n\n            $errorMessage = $e->getMessage();\n            Log::channel('upload')->error(json_encode($logParams), [\n                'Action' => 'Errore durante la creazione della directory',\n                'error' => $errorMessage,\n                'path' => $path]);\n\n            throw new Exception($errorMessage);\n        }\n    }\n\n}"
}
,
{
  "name": "SaveCollectionTraits",
  "code": "<?php\n\nnamespace App\\Traits;\n\nuse App\\Models\\Collection;\nuse Illuminate\\Support\\Facades\\Log;\n\ntrait SaveCollectionTraits\n{\n\n    use HasPermissionTrait;\n\n    /**\n     * Salva una nuova collezione nel database.\n     */\n\n    public function save($collectionId)\n    {\n        try {\n            // Esegui la validazione basata sui decorator\n            $this->validate();\n\n            // Recupera la collection\n            $collection = Collection::findOrFail($collectionId);\n\n            // Verifica il permesso \"update_collection\"\n            $this->hasPermission($collection, 'update_collection');\n\n            // Aggiorna la collection con i dati validati\n            $collection->update([\n                'collection_name' => $this->collection_name,\n                'type' => $this->type,\n                'position' => $this->position,\n                'EGI_number' => $this->EGI_number,\n                'floor_price' => $this->floor_price,\n                'description' => $this->description,\n                'is_published' => $this->is_published,\n                'url_collection_site' => $this->url_collection_site,\n            ]);\n\n            // Ricarica i dati aggiornati dal database\n            $this->collection = Collection::find($collectionId);\n\n            // Flash del messaggio di successo\n            session()->flash('message', 'Collezione aggiornata con successo!');\n\n        } catch (\\Illuminate\\Database\\Eloquent\\ModelNotFoundException $e) {\n            // Gestisci il caso in cui la collection non viene trovata\n            Log::channel('florenceegi')->error('Collection not found: ' . $e->getMessage());\n            $this->dispatch('swal:error', [\n                'title' => 'Errore',\n                'text' => 'La collezione specificata non esiste.',\n            ]);\n        } catch (\\Illuminate\\Auth\\Access\\AuthorizationException $e) {\n            // Gestisci i problemi di autorizzazione\n            Log::channel('florenceegi')->warning('Autorizzazione fallita: ' . $e->getMessage());\n            $this->dispatch('swal:error', [\n                'title' => 'Autorizzazione Negata',\n                'text' => $e->getMessage(),\n            ]);\n        } catch (\\Exception $e) {\n            // Gestisci altre eccezioni generiche\n            Log::channel('florenceegi')->error('Errore durante l\\'aggiornamento della collezione: ' . $e->getMessage());\n            $this->dispatch('swal:error', [\n                'title' => 'Errore Inaspettato',\n                'text' => 'Si è verificato un errore durante l\\'aggiornamento della collezione. Riprova più tardi.',\n            ]);\n        }\n    }\n}"
}
,
{
  "name": "UsesUuid",
  "code": "<?php\n\n\nnamespace App\\Traits;\n\nuse Illuminate\\Support\\Str;\n\ntrait UsesUuid\n{\n    protected static function bootUsesUuid()\n    {\n        static::creating(function ($model) {\n            if (!$model->getKey()) {\n                $model->{$model->getKeyName()} = (string) Str::uuid();\n            }\n        });\n    }\n\n    public function getIncrementing()\n    {\n        return false;\n    }\n\n    public function getKeyType()\n    {\n        return 'string';\n    }\n}"
}
,
{
  "name": "AppLayout",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\nuse Illuminate\\View\\View;\n\nclass AppLayout extends Component\n{\n    /**\n     * Get the view / contents that represents the component.\n     */\n    public function render(): View\n    {\n        return view('layouts.app');\n    }\n}"
}
,
{
  "name": "AuthSessionStatus",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\nuse Illuminate\\View\\View;\n\nclass AuthSessionStatus extends Component\n{\n    public function __construct(\n        public ?string $status = null\n    ) {}\n\n    public function render(): View\n    {\n        return view('components.auth-session-status');\n    }\n}"
}
,
{
  "name": "BackButton",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass BackButton extends Component\n{\n    public $label;\n\n    /**\n     * Create a new component instance.\n     *\n     * @param string $label\n     */\n    public function __construct($label = 'Torna Indietro')\n    {\n        $this->label = __('label.came_to_back');\n    }\n\n    /**\n     * Get the view / contents that represent the component.\n     *\n     * @return \\Illuminate\\View\\View|string\n     */\n    public function render()\n    {\n        return view('components.back-button');\n    }\n}"
}
,
{
  "name": "CollectionCard",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse App\\Models\\Collection;\nuse Closure;\nuse Illuminate\\Contracts\\View\\View;\nuse Illuminate\\View\\Component;\n\nclass CollectionCard extends Component\n{\n    public $collection;\n    public $id;\n\n    /**\n     * Create a new component instance.\n     */\n    public function __construct($id)\n    {\n\n        $this->id = $id;\n\n        // Carica la collection usando l'ID\n        $this->collection = Collection::findOrFail($id);\n    }\n\n    /**\n     * Get the view / contents that represent the component.\n     */\n    public function render(): View|Closure|string\n    {\n        return view('components.collection-card', [\n            'collection' => $this->collection,\n            'id' => $this->id\n        ]);\n    }\n}"
}
,
{
  "name": "FormButton",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass FormButton extends Component\n{\n    public function __construct(\n        public string $type = 'button',\n        public ?string $style = 'primary',\n        public ?string $size = null,\n        public ?string $class = '',\n    ) {}\n\n    public function render()\n    {\n        return view('components.form-button');\n    }\n} "
}
,
{
  "name": "FormInput",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse App\\Repositories\\IconRepository;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\View\\Component;\n\nclass FormInput extends Component\n{\n    public ?string $iconHtml = null;\n\n    public function __construct(\n        public string $type,\n        public string $label,\n        public string $model,\n        public string $id,\n        public bool $required = false,\n        public ?string $class = '',\n        public ?string $placeholder = '',\n        public ?string $icon = null, // Nome dell'icona da recuperare\n        public ?string $iconClass = null, // Classe personalizzata per l'icona\n        public string $datatip,\n        public string $style = 'primary',\n    ) {\n        // Validate style\n        $validStyles = ['primary', 'secondary', 'accent', 'info', 'success', 'warning', 'error'];\n        if (! in_array($style, $validStyles)) {\n            throw new \\InvalidArgumentException('Style must be one of: '.implode(', ', $validStyles));\n        }\n\n        // Log::channel('florenceegi')->info( 'FormInput: iconClass: (' . $iconClass .  ') name: (' . $icon .')');\n\n        // Recupera l'icona dal repository\n        if ($icon) {\n            $repository = app(IconRepository::class);\n            $this->iconHtml = $repository->getIcon($icon, 'elegant', $iconClass);\n\n        }\n    }\n\n    public function render()\n    {\n        return view('components.form-input');\n    }\n}"
}
,
{
  "name": "FormInputIcon",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass FormInputIcon extends Component\n{\n    public function __construct(\n        public string $type = 'text',\n        public string $label = '',\n        public string $model = '',\n        public string $id = '',\n        public bool $required = false,\n        public string $class = '',\n        public string $placeholder = '',\n        public string $icon = '',\n        public string $iconPosition = 'right', // 'left' o 'right'\n        public string $value = ''\n    ) {}\n\n    public function render()\n    {\n        return view('components.form-input-icon');\n    }\n} "
}
,
{
  "name": "FormSelect",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass FormSelect extends Component\n{\n    /**\n     * Create a new component instance.\n     */\n    public function __construct(\n        public string $label,\n        public string $model,\n        public string $id,\n        public bool $required = false,\n        public string $class = '',\n        public string $style = 'primary',\n        public string $maxWidth = 'xs'\n    ) {\n        // Validate style\n        $validStyles = ['primary', 'secondary', 'accent', 'info', 'success', 'warning', 'error'];\n        if (!in_array($style, $validStyles)) {\n            throw new \\InvalidArgumentException(\"Style must be one of: \" . implode(', ', $validStyles));\n        }\n\n        // Validate maxWidth\n        $validWidths = ['xs', 'sm', 'md', 'lg', 'xl'];\n        if (!in_array($maxWidth, $validWidths)) {\n            throw new \\InvalidArgumentException(\"MaxWidth must be one of: \" . implode(', ', $validWidths));\n        }\n    }\n\n    /**\n     * Get the view / contents that represent the component.\n     */\n    public function render()\n    {\n        return view('components.form-select');\n    }\n} "
}
,
{
  "name": "GuestLayout",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\nuse Illuminate\\View\\View;\n\nclass GuestLayout extends Component\n{\n    /**\n     * Get the view / contents that represents the component.\n     */\n    public function render(): View\n    {\n        return view('layouts.guest');\n    }\n}"
}
,
{
  "name": "GuestWelcomeLayout",
  "code": "<?php\n\ndeclare(strict_types=1);\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass GuestWelcomeLayout extends Component\n{\n    public function render()\n    {\n        return view('layouts.guest-welcome');\n    }\n} "
}
,
{
  "name": "ImageUploader",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse App\\Models\\Collection;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\View\\Component;\nuse App\\Repositories\\IconRepository;\n\nclass ImageUploader extends Component\n{\n    public ?string $iconHtml = null;\n\n    public function __construct(\n        public string $model,\n        public string $id,\n        public string $label,\n        public $image ='',\n        public string $removeMethod = 'removeImage',\n        public ?string $icon = null, // Nome dell'icona da recuperare\n        public ?string $iconClass = null // Classe personalizzata per l'icona\n    ) {\n\n        // Log::channel('florenceegi')->info( 'Class: ImageUploader. Method: Construct(). Action: iconClass: (' . $iconClass .  ') name: (' . $icon .')');\n        // Log::channel('florenceegi')->info( 'Class: ImageUploader. Method: Construct(). Action: model: (' . $model .  ')');\n        // Log::channel('florenceegi')->info( 'Class: ImageUploader. Method: Construct(). Action: image: (' . $image .  ')');\n\n        // Recupera l'icona dal repository\n        if ($icon) {\n\n            $repository = app(IconRepository::class);\n            $this->iconHtml = $repository->getIcon($icon, 'elegant', $iconClass);\n        }\n    }\n\n    public function render()\n    {\n\n        return view('components.image-uploader');\n    }\n}"
}
,
{
  "name": "RepoIcon",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\nuse App\\Repositories\\IconRepository;\n\nclass RepoIcon extends Component\n{\n    public ?string $iconHtml = null;\n\n    public function __construct(\n        public string $name,\n        public ?string $class = null\n    ) {\n        $repository = app(IconRepository::class);\n        $this->iconHtml = $repository->getIcon($name, 'elegant', $class);\n    }\n\n    public function render()\n    {\n        return view('components.repo-icon');\n    }\n}"
}
,
{
  "name": "Separator",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass Separator extends Component\n{\n    public $class;\n\n    /**\n     * Create a new component instance.\n     *\n     * @param string $class\n     */\n    public function __construct($class = 'border-gray-200 dark:border-gray-600')\n    {\n        $this->class = $class;\n    }\n\n    /**\n     * Get the view / contents that represent the component.\n     *\n     * @return \\Illuminate\\View\\View|string\n     */\n    public function render()\n    {\n        return view('components.separator');\n    }\n}"
}
,
{
  "name": "SuggestionIcon",
  "code": "<?php\n\nnamespace App\\View\\Components;\n\nuse Illuminate\\View\\Component;\n\nclass SuggestionIcon extends Component\n{\n    public string $tooltip;\n    public string $iconColor;\n\n    public function __construct(string $tooltip = 'Suggestion', string $iconColor = '#5f6368')\n    {\n        $this->tooltip = $tooltip;\n        $this->iconColor = $iconColor;\n    }\n\n    public function render()\n    {\n        return view('components.suggestion-icon');\n    }\n}"
}

]
